-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Toolkit for regex-base
--   
--   A regular expression toolkit for regex-base with compile-time checking
--   of RE syntax, data types for matches and captures, a text replacement
--   toolkit, portable options, high-level AWK-like tools for building text
--   processing apps, regular expression macros with parsers and test
--   bench, comprehensive documentation, tutorials and copious examples.
@package regex
@version 1.1.0.2


module Text.RE

module Text.RE.REOptions

-- | the default API uses these simple, universal RE options, which get
--   auto-converted into the appropriate back-end <a>REOptions_</a>
data SimpleREOptions

-- | case-sensitive with ^ and $ matching the start and end of a line
MultilineSensitive :: SimpleREOptions

-- | case-insensitive with ^ and $ matsh the start and end of a line
MultilineInsensitive :: SimpleREOptions

-- | case-sensitive with ^ and $ matching the start and end of the input
--   text
BlockSensitive :: SimpleREOptions

-- | case-insensitive with ^ and $ matching the start and end of the input
--   text
BlockInsensitive :: SimpleREOptions

-- | the general options for an RE are dependent on which back end is being
--   used and are parameterised over the <tt>RE</tt> type for the back end,
--   and its <tt>CompOption</tt> and <tt>ExecOption</tt> types (the
--   compile-time and execution time options, respectively); each back end
--   will define an <tt>REOptions</tt> type that fills out these three type
--   parameters with the appropriate types (see, for example,
--   <a>Text.RE.TDFA</a>)
data REOptions_ r c e
REOptions :: !Macros r -> !c -> !e -> REOptions_ r c e

-- | the available TestBench RE macros
[optionsMacs] :: REOptions_ r c e -> !Macros r

-- | the back end compile-time options
[optionsComp] :: REOptions_ r c e -> !c

-- | the back end execution-time options
[optionsExec] :: REOptions_ r c e -> !e

-- | our macro tables are parameterised over the back end <tt>RE</tt> type
--   and and just associate each <tt>MacroID</tt> with an <tt>RE</tt>
--   (which may in turn contain macros to be expanded)
type Macros r = HashMap MacroID r

-- | <tt>MacroID</tt> is just a wrapped <tt>String</tt> type with an
--   <tt>IsString</tt> instance
newtype MacroID
MacroID :: String -> MacroID
[getMacroID] :: MacroID -> String

-- | a macro table containing no entries
emptyMacros :: Macros r
instance GHC.Show.Show Text.RE.REOptions.SimpleREOptions
instance GHC.Classes.Ord Text.RE.REOptions.SimpleREOptions
instance GHC.Classes.Eq Text.RE.REOptions.SimpleREOptions
instance GHC.Enum.Enum Text.RE.REOptions.SimpleREOptions
instance GHC.Enum.Bounded Text.RE.REOptions.SimpleREOptions
instance GHC.Show.Show Text.RE.REOptions.MacroID
instance GHC.Classes.Eq Text.RE.REOptions.MacroID
instance GHC.Classes.Ord Text.RE.REOptions.MacroID
instance Data.String.IsString Text.RE.REOptions.MacroID
instance (GHC.Show.Show r, GHC.Show.Show c, GHC.Show.Show e) => GHC.Show.Show (Text.RE.REOptions.REOptions_ r c e)
instance Language.Haskell.TH.Syntax.Lift Text.RE.REOptions.SimpleREOptions
instance Data.Hashable.Class.Hashable Text.RE.REOptions.MacroID

module Text.RE.Replace

-- | replace all with a template, $0 for whole text, $1 for first capture,
--   etc.
replaceAll :: Replace a => a -> Matches a -> a

-- | substitutes using a function that takes the full Match context and
--   returns the same replacement text as the _phi_phi context.
replaceAllCaptures :: Replace a => REContext -> (Match a -> RELocation -> Capture a -> Maybe a) -> Matches a -> a

-- | replaceAllCaptures_ is like like replaceAllCaptures but takes the
--   Replace methods through the ReplaceMethods argument
replaceAllCaptures_ :: Extract a => ReplaceMethods a -> REContext -> (Match a -> RELocation -> Capture a -> Maybe a) -> Matches a -> a

-- | replaceAllCapturesM is just a monadically generalised version of
--   replaceAllCaptures_
replaceAllCapturesM :: (Extract a, Monad m) => ReplaceMethods a -> REContext -> (Match a -> RELocation -> Capture a -> m (Maybe a)) -> Matches a -> m a
replace :: Replace a => a -> Match a -> a

-- | substitutes using a function that takes the full Match context and
--   returns the same replacement text as the _phi_phi context.
replaceCaptures :: Replace a => REContext -> (Match a -> RELocation -> Capture a -> Maybe a) -> Match a -> a

-- | replaceCaptures_ is like replaceCaptures but takes the Replace methods
--   through the ReplaceMethods argument
replaceCaptures_ :: Extract a => ReplaceMethods a -> REContext -> (Match a -> RELocation -> Capture a -> Maybe a) -> Match a -> a

-- | replaceCapturesM is just a monadically generalised version of
--   replaceCaptures_
replaceCapturesM :: (Monad m, Extract a) => ReplaceMethods a -> REContext -> (Match a -> RELocation -> Capture a -> m (Maybe a)) -> Match a -> m a

-- | <tt>REContext</tt> specifies which contexts the substitutions should
--   be applied
data REContext

-- | substitutions should be applied to the top-level only, the text that
--   matched the whole RE
TOP :: REContext

-- | substitutions should only be applied to the text captured by bracketed
--   sub-REs
SUB :: REContext

-- | the substitution function should be applied to all captures, the top
--   level and the sub-expression captures
ALL :: REContext

-- | the <tt>RELocation</tt> information passed into the substitution
--   function specifies which sub-expression is being substituted
data RELocation
RELocation :: Int -> CaptureOrdinal -> RELocation

-- | the zero-based, i-th string to be matched, when matching all strings,
--   zero when only the first string is being matched
[locationMatch] :: RELocation -> Int

-- | 0, when matching the top-level string matched by the whole RE, 1 for
--   the top-most, left-most redex captured by bracketed sub-REs, etc.
[locationCapture] :: RELocation -> CaptureOrdinal

-- | True iff the location references a complete match (i.e., not a
--   bracketed capture)
isTopLocation :: RELocation -> Bool

-- | the result of matching a RE against a text (with <tt>*=~</tt>),
--   retaining the text that was matched against
data Matches a
Matches :: !a -> ![Match a] -> Matches a

-- | the source text being matched
[matchesSource] :: Matches a -> !a

-- | all <a>Match</a> instances found, left to right
[allMatches] :: Matches a -> ![Match a]

-- | tests whether the RE matched the source text at all
anyMatches :: Matches a -> Bool

-- | count the matches
countMatches :: Matches a -> Int

-- | list the texts that Matched
matches :: Matches a -> [a]

-- | extract the main capture from each match
mainCaptures :: Matches a -> [Capture a]

-- | the result of matching a RE to a text once (with <tt>?=~</tt>),
--   retaining the text that was matched against
data Match a
Match :: !a -> !CaptureNames -> !Array CaptureOrdinal (Capture a) -> Match a

-- | the whole source text
[matchSource] :: Match a -> !a

-- | the RE's capture names
[captureNames] :: Match a -> !CaptureNames

-- | <ol>
--   <li>.n-1 captures, starting with the text matched by the whole RE</li>
--   </ol>
[matchArray] :: Match a -> !Array CaptureOrdinal (Capture a)

-- | Construct a Match that does not match anything.
noMatch :: a -> Match a

-- | an empty array of Capture
emptyMatchArray :: Array CaptureOrdinal (Capture a)

-- | tests whether the RE matched the source text at all
matched :: Match a -> Bool

-- | yields the text matched by the RE, Nothing if no match
matchedText :: Match a -> Maybe a

-- | the top-level capture if the source text matched the RE, Nothing
--   otherwise
matchCapture :: Match a -> Maybe (Capture a)

-- | the main top-level capture (capture '0'') and the sub captures if the
--   text matched the RE, <tt>Nothing</tt> otherwise
matchCaptures :: Match a -> Maybe (Capture a, [Capture a])

-- | an alternative for captureText
(!$$) :: Match a -> CaptureID -> a
infixl 9 !$$

-- | look up the text of the nth capture, 0 being the match of the whole RE
--   against the source text, 1, the first bracketed sub-expression to be
--   matched and so on
captureText :: CaptureID -> Match a -> a

-- | an alternative for captureTextMaybe
(!$$?) :: Match a -> CaptureID -> Maybe a

-- | look up the text of the nth capture (0 being the match of the whole),
--   returning Nothing if the Match doesn't contain the capture
captureTextMaybe :: CaptureID -> Match a -> Maybe a

-- | an alternative for capture
(!$) :: Match a -> CaptureID -> Capture a
infixl 9 !$

-- | look up the nth capture, 0 being the match of the whole RE against the
--   source text, 1, the first bracketed sub-expression to be matched and
--   so on
capture :: CaptureID -> Match a -> Capture a

-- | an alternative for capture captureMaybe
(!$?) :: Match a -> CaptureID -> Maybe (Capture a)

-- | look up the nth capture, 0 being the match of the whole RE against the
--   source text, 1, the first bracketed sub-expression to be matched and
--   so on, returning Nothing if there is no such capture, or if the
--   capture failed to capture anything (being in a failed alternate)
captureMaybe :: CaptureID -> Match a -> Maybe (Capture a)

-- | convert a regex-base native MatchText into a regex Match type
convertMatchText :: RegexFix regex source => regex -> source -> MatchText source -> Match source

-- | the matching of a single sub-expression against part of the source
--   text
data Capture a
Capture :: !a -> !a -> !Int -> !Int -> Capture a

-- | the whole text that was searched
[captureSource] :: Capture a -> !a

-- | the text that was matched
[capturedText] :: Capture a -> !a

-- | the number of characters preceding the match with -1 used if no text
--   was captured by the RE (not even the empty string)
[captureOffset] :: Capture a -> !Int

-- | the number of chacter in the captured sub-string
[captureLength] :: Capture a -> !Int

-- | test if the capture has matched any text
hasCaptured :: Capture a -> Bool

-- | returns the text preceding the match
capturePrefix :: Extract a => Capture a -> a

-- | returns the text after the match
captureSuffix :: Extract a => Capture a -> a

-- | CaptureID identifies captures, either by number (e.g., [cp|1|]) or
--   name (e.g., [cp|foo|]).
data CaptureID
IsCaptureOrdinal :: CaptureOrdinal -> CaptureID
IsCaptureName :: CaptureName -> CaptureID

-- | the dictionary for named captures stored in compiled regular
--   expressions associates
type CaptureNames = HashMap CaptureName CaptureOrdinal

-- | an empty <a>CaptureNames</a> dictionary
noCaptureNames :: CaptureNames

-- | a <a>CaptureName</a> is just the text of the name
newtype CaptureName
CaptureName :: Text -> CaptureName
[getCaptureName] :: CaptureName -> Text

-- | a <a>CaptureOrdinal</a> is just the number of the capture, starting
--   with 0 for the whole of the text matched, then in leftmost, outermost
newtype CaptureOrdinal
CaptureOrdinal :: Int -> CaptureOrdinal
[getCaptureOrdinal] :: CaptureOrdinal -> Int

-- | look up a <a>CaptureID</a> in the <a>CaptureNames</a> dictionary
findCaptureID :: CaptureID -> CaptureNames -> Either String CaptureOrdinal

-- | Replace provides the missing needed to replace the matched text in a
--   <tt>Replace a =&gt; Match a</tt>.
class (Show a, Eq a, Ord a, Extract a, Monoid a) => Replace a

-- | length function for a
lengthR :: Replace a => a -> Int

-- | inject String into a
packR :: Replace a => String -> a

-- | project a onto a String
unpackR :: Replace a => a -> String

-- | inject into Text
textifyR :: Replace a => a -> Text

-- | project Text onto a
detextifyR :: Replace a => Text -> a

-- | split into lines
linesR :: Replace a => a -> [a]

-- | concatenate a list of lines
unlinesR :: Replace a => [a] -> a

-- | append a newline
appendNewlineR :: Replace a => a -> a

-- | apply a substitution function to a Capture
substR :: Replace a => (a -> a) -> Capture a -> a

-- | convert a template containing $0, $1, etc., in the first argument,
--   into a <tt>phi</tt> replacement function for use with
--   replaceAllCaptures and replaceCaptures
parseTemplateR :: Replace a => a -> Match a -> RELocation -> Capture a -> Maybe a

-- | a selection of the Replace methods can be encapsulated with
--   ReplaceMethods for the higher-order replacement functions
data ReplaceMethods a
ReplaceMethods :: (a -> Int) -> ((a -> a) -> Capture a -> a) -> ReplaceMethods a
[methodLength] :: ReplaceMethods a -> a -> Int
[methodSubst] :: ReplaceMethods a -> (a -> a) -> Capture a -> a

-- | replaceMethods encapsulates ReplaceMethods a from a Replace a context
replaceMethods :: Replace a => ReplaceMethods a

module Text.RE.TestBench.Parsers
parseInteger :: Replace a => a -> Maybe Int
parseHex :: Replace a => a -> Maybe Int
parseDouble :: Replace a => a -> Maybe Double
parseString :: Replace a => a -> Maybe Text
parseSimpleString :: Replace a => a -> Maybe Text
parseDate :: Replace a => a -> Maybe Day
parseSlashesDate :: Replace a => a -> Maybe Day
parseTimeOfDay :: Replace a => a -> Maybe TimeOfDay
parseTimeZone :: Replace a => a -> Maybe TimeZone
parseDateTime :: Replace a => a -> Maybe UTCTime
parseDateTime8601 :: Replace a => a -> Maybe UTCTime
parseDateTimeCLF :: Replace a => a -> Maybe UTCTime
parseShortMonth :: Replace a => a -> Maybe Int
shortMonthArray :: Array Int Text
type IPV4Address = (Word8, Word8, Word8, Word8)
parseIPv4Address :: Replace a => a -> Maybe IPV4Address
data Severity
Emerg :: Severity
Alert :: Severity
Crit :: Severity
Err :: Severity
Warning :: Severity
Notice :: Severity
Info :: Severity
Debug :: Severity
parseSeverity :: Replace a => a -> Maybe Severity
severityKeywords :: Severity -> (Text, [Text])

module Text.RE.TestBench

-- | each macro can reference others, the whole environment being required
--   for each macro, so we use a Lazy HashMap
type MacroEnv = HashMap MacroID MacroDescriptor

-- | describes a macro, giving the text of the RE and a summary description
data MacroDescriptor
MacroDescriptor :: !RegexSource -> ![String] -> ![String] -> ![TestResult] -> !Maybe FunctionID -> !String -> MacroDescriptor

-- | the RE
[macroSource] :: MacroDescriptor -> !RegexSource

-- | some sample matches
[macroSamples] :: MacroDescriptor -> ![String]

-- | some sample non-matches
[macroCounterSamples] :: MacroDescriptor -> ![String]

-- | validation test results
[macroTestResults] :: MacroDescriptor -> ![TestResult]

-- | WA, the parser function
[macroParser] :: MacroDescriptor -> !Maybe FunctionID

-- | summary comment
[macroDescription] :: MacroDescriptor -> !String

-- | a RE that should work for POSIX and PCRE with open brackets ('(')
--   represented as follows: ( mere symbol (?: used for grouping only, not
--   for captures (}: used for captures only, not for grouping (]: used for
--   captures and grouping ( do not modify
newtype RegexSource
RegexSource :: String -> RegexSource
[_RegexSource] :: RegexSource -> String

-- | do we need the captures in the RE or would they be stripped out where
--   possible
data WithCaptures

-- | include all captures
InclCaptures :: WithCaptures

-- | remove captures where possible
ExclCaptures :: WithCaptures

-- | what flavour of regex are we dealing with
data RegexType

-- | test RegexType for TDFA/PCREness
isTDFA :: RegexType -> Bool

-- | test RegexType for TDFA/PCREness
isPCRE :: RegexType -> Bool
presentRegexType :: RegexType -> String

-- | construct a macro table suitable for use with the RE compilers
mkMacros :: (Monad m, Functor m) => (String -> m r) -> RegexType -> WithCaptures -> MacroEnv -> m (Macros r)

-- | format a macros table as a markdown table
formatMacroTable :: RegexType -> MacroEnv -> String

-- | generate a plain text summary of a macro
formatMacroSummary :: RegexType -> MacroEnv -> MacroID -> String

-- | list the source REs for each macro in plain text
formatMacroSources :: RegexType -> WithCaptures -> MacroEnv -> String

-- | list the source of a single macro in plain text
formatMacroSource :: RegexType -> WithCaptures -> MacroEnv -> MacroID -> String
mdRegexSource :: RegexType -> WithCaptures -> MacroEnv -> MacroDescriptor -> String

-- | test that a MacroEnv is passing all of its built-in tests
testMacroEnv :: String -> RegexType -> MacroEnv -> IO Bool
runTests :: (Eq a, Show a) => RegexType -> (String -> Maybe a) -> [(String, a)] -> MacroEnv -> MacroID -> MacroDescriptor -> MacroDescriptor
runTests' :: (Eq a, Show a) => RegexType -> (Match String -> Maybe a) -> [(String, a)] -> MacroEnv -> MacroID -> MacroDescriptor -> MacroDescriptor

-- | the result of matching a RE to a text once (with <tt>?=~</tt>),
--   retaining the text that was matched against
data Match a

module Text.RE.ZeInternals.Types.Poss
data Poss a
Eek :: String -> Poss a
Yup :: a -> Poss a
poss :: (String -> b) -> (a -> b) -> Poss a -> b
poss2either :: Poss a -> Either String a
instance GHC.Show.Show a => GHC.Show.Show (Text.RE.ZeInternals.Types.Poss.Poss a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Text.RE.ZeInternals.Types.Poss.Poss a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Text.RE.ZeInternals.Types.Poss.Poss a)
instance GHC.Base.Functor Text.RE.ZeInternals.Types.Poss.Poss
instance GHC.Base.Applicative Text.RE.ZeInternals.Types.Poss.Poss
instance GHC.Base.Monad Text.RE.ZeInternals.Types.Poss.Poss
instance Control.Monad.Fail.MonadFail Text.RE.ZeInternals.Types.Poss.Poss

module Text.RE.Tools.IsRegex

-- | the <a>IsRegex</a> class allows polymorhic tools to be written that
--   will work with a variety of regex back ends and text types
class Replace s => IsRegex re s

-- | finding the first match
matchOnce :: IsRegex re s => re -> s -> Match s

-- | finding all matches
matchMany :: IsRegex re s => re -> s -> Matches s

-- | compiling an RE, failing if the RE is not well formed
makeRegex :: (IsRegex re s, Functor m, Monad m, MonadFail m) => s -> m re

-- | comiling an RE, specifying the <a>SimpleREOptions</a>
makeRegexWith :: (IsRegex re s, Functor m, Monad m, MonadFail m) => SimpleREOptions -> s -> m re

-- | compiling a <a>SearchReplace</a> template from the RE text and the
--   template Text, failing if they are not well formed
makeSearchReplace :: (IsRegex re s, Functor m, Monad m, MonadFail m, IsRegex re s) => s -> s -> m (SearchReplace re s)

-- | compiling a <a>SearchReplace</a> template specifying the
--   <a>SimpleREOptions</a> for the RE
makeSearchReplaceWith :: (IsRegex re s, Functor m, Monad m, MonadFail m, IsRegex re s) => SimpleREOptions -> s -> s -> m (SearchReplace re s)

-- | incorporate an escaped string into a compiled RE with the default
--   options
makeEscaped :: (IsRegex re s, Functor m, Monad m, MonadFail m) => (s -> s) -> s -> m re

-- | incorporate an escaped string into a compiled RE with the specified
--   <a>SimpleREOptions</a>
makeEscapedWith :: (IsRegex re s, Functor m, Monad m, MonadFail m) => SimpleREOptions -> (s -> s) -> s -> m re

-- | extract the text of the RE from the RE
regexSource :: IsRegex re s => re -> s

-- | contains a compiled RE and replacement template
data SearchReplace re s
SearchReplace :: !re -> !s -> SearchReplace re s

-- | the RE to match a string to replace
[getSearch] :: SearchReplace re s -> !re

-- | the replacement template with ${cap} used to identify a capture (by
--   number or name if one was given) and <tt>$$</tt> being used to escape
--   a single <a>$</a>
[getTemplate] :: SearchReplace re s -> !s

-- | search and replace all matches in the argument text; e.g., this
--   function will convert every YYYY-MM-DD format date in its argument
--   text into a DD/MM/YYYY date:
--   
--   <pre>
--   searchReplaceAll [ed|${y}([0-9]{4})-0*${m}([0-9]{2})-0*${d}([0-9]{2})///${d}/${m}/${y}|]
--   </pre>
searchReplaceAll :: IsRegex re s => SearchReplace re s -> s -> s

-- | search and replace the first occurrence only (if any) in the input
--   text e.g., to prefix the first string of four hex digits in the imput
--   text, if any, with <tt>0x</tt>:
--   
--   <pre>
--   searchReplaceFirst [ed|[0-9A-Fa-f]{4}///0x$0|]
--   </pre>
searchReplaceFirst :: IsRegex re s => SearchReplace re s -> s -> s

module Text.RE.Tools.Lex

-- | a simple regex-based scanner interpreter for prototyping scanners
alex :: IsRegex re s => [(re, Match s -> Maybe t)] -> t -> s -> [t]

-- | a higher order version of <a>alex</a> parameterised over the
--   <tt>matchOnce</tt> function
alex' :: Replace s => (re -> s -> Match s) -> [(re, Match s -> Maybe t)] -> t -> s -> [t]

-- | the <a>IsRegex</a> class allows polymorhic tools to be written that
--   will work with a variety of regex back ends and text types
class Replace s => IsRegex re s

-- | finding the first match
matchOnce :: IsRegex re s => re -> s -> Match s

-- | finding all matches
matchMany :: IsRegex re s => re -> s -> Matches s

-- | compiling an RE, failing if the RE is not well formed
makeRegex :: (IsRegex re s, Functor m, Monad m, MonadFail m) => s -> m re

-- | comiling an RE, specifying the <a>SimpleREOptions</a>
makeRegexWith :: (IsRegex re s, Functor m, Monad m, MonadFail m) => SimpleREOptions -> s -> m re

-- | compiling a <a>SearchReplace</a> template from the RE text and the
--   template Text, failing if they are not well formed
makeSearchReplace :: (IsRegex re s, Functor m, Monad m, MonadFail m, IsRegex re s) => s -> s -> m (SearchReplace re s)

-- | compiling a <a>SearchReplace</a> template specifying the
--   <a>SimpleREOptions</a> for the RE
makeSearchReplaceWith :: (IsRegex re s, Functor m, Monad m, MonadFail m, IsRegex re s) => SimpleREOptions -> s -> s -> m (SearchReplace re s)

-- | incorporate an escaped string into a compiled RE with the default
--   options
makeEscaped :: (IsRegex re s, Functor m, Monad m, MonadFail m) => (s -> s) -> s -> m re

-- | incorporate an escaped string into a compiled RE with the specified
--   <a>SimpleREOptions</a>
makeEscapedWith :: (IsRegex re s, Functor m, Monad m, MonadFail m) => SimpleREOptions -> (s -> s) -> s -> m re

-- | extract the text of the RE from the RE
regexSource :: IsRegex re s => re -> s

-- | contains a compiled RE and replacement template
data SearchReplace re s
SearchReplace :: !re -> !s -> SearchReplace re s

-- | the RE to match a string to replace
[getSearch] :: SearchReplace re s -> !re

-- | the replacement template with ${cap} used to identify a capture (by
--   number or name if one was given) and <tt>$$</tt> being used to escape
--   a single <a>$</a>
[getTemplate] :: SearchReplace re s -> !s

-- | search and replace all matches in the argument text; e.g., this
--   function will convert every YYYY-MM-DD format date in its argument
--   text into a DD/MM/YYYY date:
--   
--   <pre>
--   searchReplaceAll [ed|${y}([0-9]{4})-0*${m}([0-9]{2})-0*${d}([0-9]{2})///${d}/${m}/${y}|]
--   </pre>
searchReplaceAll :: IsRegex re s => SearchReplace re s -> s -> s

-- | search and replace the first occurrence only (if any) in the input
--   text e.g., to prefix the first string of four hex digits in the imput
--   text, if any, with <tt>0x</tt>:
--   
--   <pre>
--   searchReplaceFirst [ed|[0-9A-Fa-f]{4}///0x$0|]
--   </pre>
searchReplaceFirst :: IsRegex re s => SearchReplace re s -> s -> s

module Text.RE.Tools.Grep

-- | operates a bit like classic <tt>grep</tt> printing out the lines
--   matched
grep :: IsRegex re ByteString => Verbosity -> re -> FilePath -> IO ()

-- | specifies whether to return the lines matched or missed
data Verbosity
LinesMatched :: Verbosity
LinesNotMatched :: Verbosity

-- | <a>grepLines</a> returns a <a>Line</a> for each line in the file,
--   listing all of the <a>Matches</a> for that line
data Line s
Line :: LineNo -> Matches s -> Line s

-- | the <a>LineNo</a> for this line
[getLineNumber] :: Line s -> LineNo

-- | all the <a>Matches</a> of the RE on this line
[getLineMatches] :: Line s -> Matches s

-- | returns a <a>Line</a> for each line in the file, enumerating all of
--   the matches for that line
grepLines :: IsRegex re ByteString => re -> FilePath -> IO [Line ByteString]

-- | returns a <a>Line</a> for each line in the argument text, enumerating
--   all of the matches for that line
grepFilter :: IsRegex re s => re -> s -> [Line s]

-- | a GrepScript lists RE-action associations, with the first RE to match
--   a line selecting the action to be executed on each line in the file
type GrepScript re s t = [(re, LineNo -> Matches s -> Maybe t)]

-- | given a list of lines, apply the <a>GrepScript</a> to each line of the
--   file
grepWithScript :: IsRegex re s => GrepScript re s t -> [s] -> [t]

-- | generate a grep report from a list of <a>Line</a>
report :: Verbosity -> [Line ByteString] -> String

-- | given a <tt>velocity</tt> flag filter out either the lines matched or
--   not matched
linesMatched :: Verbosity -> [Line s] -> [Line s]

-- | the <a>IsRegex</a> class allows polymorhic tools to be written that
--   will work with a variety of regex back ends and text types
class Replace s => IsRegex re s

-- | finding the first match
matchOnce :: IsRegex re s => re -> s -> Match s

-- | finding all matches
matchMany :: IsRegex re s => re -> s -> Matches s

-- | compiling an RE, failing if the RE is not well formed
makeRegex :: (IsRegex re s, Functor m, Monad m, MonadFail m) => s -> m re

-- | comiling an RE, specifying the <a>SimpleREOptions</a>
makeRegexWith :: (IsRegex re s, Functor m, Monad m, MonadFail m) => SimpleREOptions -> s -> m re

-- | compiling a <a>SearchReplace</a> template from the RE text and the
--   template Text, failing if they are not well formed
makeSearchReplace :: (IsRegex re s, Functor m, Monad m, MonadFail m, IsRegex re s) => s -> s -> m (SearchReplace re s)

-- | compiling a <a>SearchReplace</a> template specifying the
--   <a>SimpleREOptions</a> for the RE
makeSearchReplaceWith :: (IsRegex re s, Functor m, Monad m, MonadFail m, IsRegex re s) => SimpleREOptions -> s -> s -> m (SearchReplace re s)

-- | incorporate an escaped string into a compiled RE with the default
--   options
makeEscaped :: (IsRegex re s, Functor m, Monad m, MonadFail m) => (s -> s) -> s -> m re

-- | incorporate an escaped string into a compiled RE with the specified
--   <a>SimpleREOptions</a>
makeEscapedWith :: (IsRegex re s, Functor m, Monad m, MonadFail m) => SimpleREOptions -> (s -> s) -> s -> m re

-- | extract the text of the RE from the RE
regexSource :: IsRegex re s => re -> s

-- | contains a compiled RE and replacement template
data SearchReplace re s
SearchReplace :: !re -> !s -> SearchReplace re s

-- | the RE to match a string to replace
[getSearch] :: SearchReplace re s -> !re

-- | the replacement template with ${cap} used to identify a capture (by
--   number or name if one was given) and <tt>$$</tt> being used to escape
--   a single <a>$</a>
[getTemplate] :: SearchReplace re s -> !s

-- | search and replace all matches in the argument text; e.g., this
--   function will convert every YYYY-MM-DD format date in its argument
--   text into a DD/MM/YYYY date:
--   
--   <pre>
--   searchReplaceAll [ed|${y}([0-9]{4})-0*${m}([0-9]{2})-0*${d}([0-9]{2})///${d}/${m}/${y}|]
--   </pre>
searchReplaceAll :: IsRegex re s => SearchReplace re s -> s -> s

-- | search and replace the first occurrence only (if any) in the input
--   text e.g., to prefix the first string of four hex digits in the imput
--   text, if any, with <tt>0x</tt>:
--   
--   <pre>
--   searchReplaceFirst [ed|[0-9A-Fa-f]{4}///0x$0|]
--   </pre>
searchReplaceFirst :: IsRegex re s => SearchReplace re s -> s -> s

-- | our line numbers are of the proper zero-based kind
newtype LineNo
ZeroBasedLineNo :: Int -> LineNo
[getZeroBasedLineNo] :: LineNo -> Int

-- | the first line in a file
firstLine :: LineNo

-- | extract a conventional 1-based line number
getLineNo :: LineNo -> Int

-- | inject a conventional 1-based line number
lineNo :: Int -> LineNo
instance GHC.Classes.Ord Text.RE.Tools.Grep.Verbosity
instance GHC.Classes.Eq Text.RE.Tools.Grep.Verbosity
instance GHC.Show.Show Text.RE.Tools.Grep.Verbosity
instance GHC.Show.Show s => GHC.Show.Show (Text.RE.Tools.Grep.Line s)

module Text.RE.Tools.Find

-- | as we don't want the <tt>directory</tt> and FilePath dependencies we
--   will abstract the three calls we need into this record type
data FindMethods s
FindMethods :: (s -> IO Bool) -> (s -> IO [s]) -> (s -> s -> s) -> FindMethods s

-- | doesDirectoryExist from System.Directory
[doesDirectoryExistDM] :: FindMethods s -> s -> IO Bool

-- | either getDirectoryContents or listDirectory from System.Directory
[listDirectoryDM] :: FindMethods s -> s -> IO [s]

-- | <a>/</a> from System.FilePath
[combineDM] :: FindMethods s -> s -> s -> s

-- | recursively list all files whose filename matches given RE, sorting
--   the list into ascending order; if the argument path has a trailing
--   <a>/</a> then it will be removed
findMatches_ :: IsRegex re s => FindMethods s -> re -> s -> IO [s]

-- | recursively list all files whose filename matches given RE, using the
--   given function to determine which matches to accept
findMatches_' :: IsRegex re s => FindMethods s -> ([s] -> [s]) -> (Match s -> Bool) -> re -> s -> IO [s]

-- | the <a>IsRegex</a> class allows polymorhic tools to be written that
--   will work with a variety of regex back ends and text types
class Replace s => IsRegex re s

-- | finding the first match
matchOnce :: IsRegex re s => re -> s -> Match s

-- | finding all matches
matchMany :: IsRegex re s => re -> s -> Matches s

-- | compiling an RE, failing if the RE is not well formed
makeRegex :: (IsRegex re s, Functor m, Monad m, MonadFail m) => s -> m re

-- | comiling an RE, specifying the <a>SimpleREOptions</a>
makeRegexWith :: (IsRegex re s, Functor m, Monad m, MonadFail m) => SimpleREOptions -> s -> m re

-- | compiling a <a>SearchReplace</a> template from the RE text and the
--   template Text, failing if they are not well formed
makeSearchReplace :: (IsRegex re s, Functor m, Monad m, MonadFail m, IsRegex re s) => s -> s -> m (SearchReplace re s)

-- | compiling a <a>SearchReplace</a> template specifying the
--   <a>SimpleREOptions</a> for the RE
makeSearchReplaceWith :: (IsRegex re s, Functor m, Monad m, MonadFail m, IsRegex re s) => SimpleREOptions -> s -> s -> m (SearchReplace re s)

-- | incorporate an escaped string into a compiled RE with the default
--   options
makeEscaped :: (IsRegex re s, Functor m, Monad m, MonadFail m) => (s -> s) -> s -> m re

-- | incorporate an escaped string into a compiled RE with the specified
--   <a>SimpleREOptions</a>
makeEscapedWith :: (IsRegex re s, Functor m, Monad m, MonadFail m) => SimpleREOptions -> (s -> s) -> s -> m re

-- | extract the text of the RE from the RE
regexSource :: IsRegex re s => re -> s

-- | contains a compiled RE and replacement template
data SearchReplace re s
SearchReplace :: !re -> !s -> SearchReplace re s

-- | the RE to match a string to replace
[getSearch] :: SearchReplace re s -> !re

-- | the replacement template with ${cap} used to identify a capture (by
--   number or name if one was given) and <tt>$$</tt> being used to escape
--   a single <a>$</a>
[getTemplate] :: SearchReplace re s -> !s

-- | search and replace all matches in the argument text; e.g., this
--   function will convert every YYYY-MM-DD format date in its argument
--   text into a DD/MM/YYYY date:
--   
--   <pre>
--   searchReplaceAll [ed|${y}([0-9]{4})-0*${m}([0-9]{2})-0*${d}([0-9]{2})///${d}/${m}/${y}|]
--   </pre>
searchReplaceAll :: IsRegex re s => SearchReplace re s -> s -> s

-- | search and replace the first occurrence only (if any) in the input
--   text e.g., to prefix the first string of four hex digits in the imput
--   text, if any, with <tt>0x</tt>:
--   
--   <pre>
--   searchReplaceFirst [ed|[0-9A-Fa-f]{4}///0x$0|]
--   </pre>
searchReplaceFirst :: IsRegex re s => SearchReplace re s -> s -> s

module Text.RE.Tools.Edit

-- | an <a>Edits</a> script will, for each line in the file, either perform
--   the action selected by the first RE in the list, or perform all of the
--   actions on line, arranged as a pipeline
data Edits m re s

-- | for each line select the first <tt>Edit</tt> to match each line and
--   edit the line with it
Select :: ![Edit m re s] -> Edits m re s

-- | for each line apply every edit that matches in turn to the line
Pipe :: ![Edit m re s] -> Edits m re s

-- | each Edit action specifies how the match should be processed
data Edit m re s

-- | replace the match with this template text, substituting ${capture} as
--   appropriate
Template :: !SearchReplace re s -> Edit m re s

-- | use this function to replace the <a>REContext</a> specified captures
--   in each line matched
Function :: !re -> REContext -> !LineNo -> Match s -> RELocation -> Capture s -> m (Maybe s) -> Edit m re s

-- | use this function to edit each line matched
LineEdit :: !re -> !LineNo -> Matches s -> m (LineEdit s) -> Edit m re s

-- | a LineEdit is the most general action that can be performed on a line
--   and is the only means of deleting a line
data LineEdit s

-- | do not edit this line but leave as is
NoEdit :: LineEdit s

-- | replace the line with this text (terminating newline should not be
--   included)
ReplaceWith :: !s -> LineEdit s

-- | delete the this line altogether
Delete :: LineEdit s

-- | apply an <a>Edit</a> script to a single line
applyEdits :: (IsRegex re s, Monad m, Functor m) => LineNo -> Edits m re s -> s -> m s

-- | apply a single edit action to a line, the function in the first
--   argument being used to add a new line onto the end of the line where
--   appropriate; the function returns <tt>Nothing</tt> if no edit is to be
--   performed on the line, <tt>Just mempty</tt> to delete the line
applyEdit :: (IsRegex re s, Monad m, Functor m) => (s -> s) -> LineNo -> Edit m re s -> s -> m (Maybe s)

-- | apply a <a>Edit</a> to a line, using the function in the first
--   argument to append a new line to the result; Nothing should be
--   returned if no edit is to be performed, <tt>Just mempty</tt> to delete
--   the line
applyLineEdit :: Monoid s => (s -> s) -> LineEdit s -> Maybe s

-- | the <a>IsRegex</a> class allows polymorhic tools to be written that
--   will work with a variety of regex back ends and text types
class Replace s => IsRegex re s

-- | finding the first match
matchOnce :: IsRegex re s => re -> s -> Match s

-- | finding all matches
matchMany :: IsRegex re s => re -> s -> Matches s

-- | compiling an RE, failing if the RE is not well formed
makeRegex :: (IsRegex re s, Functor m, Monad m, MonadFail m) => s -> m re

-- | comiling an RE, specifying the <a>SimpleREOptions</a>
makeRegexWith :: (IsRegex re s, Functor m, Monad m, MonadFail m) => SimpleREOptions -> s -> m re

-- | compiling a <a>SearchReplace</a> template from the RE text and the
--   template Text, failing if they are not well formed
makeSearchReplace :: (IsRegex re s, Functor m, Monad m, MonadFail m, IsRegex re s) => s -> s -> m (SearchReplace re s)

-- | compiling a <a>SearchReplace</a> template specifying the
--   <a>SimpleREOptions</a> for the RE
makeSearchReplaceWith :: (IsRegex re s, Functor m, Monad m, MonadFail m, IsRegex re s) => SimpleREOptions -> s -> s -> m (SearchReplace re s)

-- | incorporate an escaped string into a compiled RE with the default
--   options
makeEscaped :: (IsRegex re s, Functor m, Monad m, MonadFail m) => (s -> s) -> s -> m re

-- | incorporate an escaped string into a compiled RE with the specified
--   <a>SimpleREOptions</a>
makeEscapedWith :: (IsRegex re s, Functor m, Monad m, MonadFail m) => SimpleREOptions -> (s -> s) -> s -> m re

-- | extract the text of the RE from the RE
regexSource :: IsRegex re s => re -> s

-- | contains a compiled RE and replacement template
data SearchReplace re s
SearchReplace :: !re -> !s -> SearchReplace re s

-- | the RE to match a string to replace
[getSearch] :: SearchReplace re s -> !re

-- | the replacement template with ${cap} used to identify a capture (by
--   number or name if one was given) and <tt>$$</tt> being used to escape
--   a single <a>$</a>
[getTemplate] :: SearchReplace re s -> !s

-- | search and replace all matches in the argument text; e.g., this
--   function will convert every YYYY-MM-DD format date in its argument
--   text into a DD/MM/YYYY date:
--   
--   <pre>
--   searchReplaceAll [ed|${y}([0-9]{4})-0*${m}([0-9]{2})-0*${d}([0-9]{2})///${d}/${m}/${y}|]
--   </pre>
searchReplaceAll :: IsRegex re s => SearchReplace re s -> s -> s

-- | search and replace the first occurrence only (if any) in the input
--   text e.g., to prefix the first string of four hex digits in the imput
--   text, if any, with <tt>0x</tt>:
--   
--   <pre>
--   searchReplaceFirst [ed|[0-9A-Fa-f]{4}///0x$0|]
--   </pre>
searchReplaceFirst :: IsRegex re s => SearchReplace re s -> s -> s

-- | our line numbers are of the proper zero-based kind
newtype LineNo
ZeroBasedLineNo :: Int -> LineNo
[getZeroBasedLineNo] :: LineNo -> Int

-- | the first line in a file
firstLine :: LineNo

-- | extract a conventional 1-based line number
getLineNo :: LineNo -> Int

-- | inject a conventional 1-based line number
lineNo :: Int -> LineNo
instance GHC.Show.Show s => GHC.Show.Show (Text.RE.Tools.Edit.LineEdit s)
instance GHC.Base.Functor Text.RE.Tools.Edit.LineEdit

module Text.RE.Tools.Sed

-- | read a file, apply an <a>Edits</a> script to each line it and write
--   the file out again; "-" is used to indicate standard input standard
--   output as appropriate
sed :: IsRegex re ByteString => Edits IO re ByteString -> FilePath -> FilePath -> IO ()

-- | apply an <a>Edits</a> script to each line of the argument text
sed' :: (IsRegex re a, Monad m, Functor m) => Edits m re a -> a -> m a

-- | an <a>Edits</a> script will, for each line in the file, either perform
--   the action selected by the first RE in the list, or perform all of the
--   actions on line, arranged as a pipeline
data Edits m re s

-- | for each line select the first <tt>Edit</tt> to match each line and
--   edit the line with it
Select :: ![Edit m re s] -> Edits m re s

-- | for each line apply every edit that matches in turn to the line
Pipe :: ![Edit m re s] -> Edits m re s

-- | each Edit action specifies how the match should be processed
data Edit m re s

-- | replace the match with this template text, substituting ${capture} as
--   appropriate
Template :: !SearchReplace re s -> Edit m re s

-- | use this function to replace the <a>REContext</a> specified captures
--   in each line matched
Function :: !re -> REContext -> !LineNo -> Match s -> RELocation -> Capture s -> m (Maybe s) -> Edit m re s

-- | use this function to edit each line matched
LineEdit :: !re -> !LineNo -> Matches s -> m (LineEdit s) -> Edit m re s

-- | a LineEdit is the most general action that can be performed on a line
--   and is the only means of deleting a line
data LineEdit s

-- | do not edit this line but leave as is
NoEdit :: LineEdit s

-- | replace the line with this text (terminating newline should not be
--   included)
ReplaceWith :: !s -> LineEdit s

-- | delete the this line altogether
Delete :: LineEdit s

-- | apply an <a>Edit</a> script to a single line
applyEdits :: (IsRegex re s, Monad m, Functor m) => LineNo -> Edits m re s -> s -> m s

-- | apply a single edit action to a line, the function in the first
--   argument being used to add a new line onto the end of the line where
--   appropriate; the function returns <tt>Nothing</tt> if no edit is to be
--   performed on the line, <tt>Just mempty</tt> to delete the line
applyEdit :: (IsRegex re s, Monad m, Functor m) => (s -> s) -> LineNo -> Edit m re s -> s -> m (Maybe s)

-- | apply a <a>Edit</a> to a line, using the function in the first
--   argument to append a new line to the result; Nothing should be
--   returned if no edit is to be performed, <tt>Just mempty</tt> to delete
--   the line
applyLineEdit :: Monoid s => (s -> s) -> LineEdit s -> Maybe s

-- | the <a>IsRegex</a> class allows polymorhic tools to be written that
--   will work with a variety of regex back ends and text types
class Replace s => IsRegex re s

-- | finding the first match
matchOnce :: IsRegex re s => re -> s -> Match s

-- | finding all matches
matchMany :: IsRegex re s => re -> s -> Matches s

-- | compiling an RE, failing if the RE is not well formed
makeRegex :: (IsRegex re s, Functor m, Monad m, MonadFail m) => s -> m re

-- | comiling an RE, specifying the <a>SimpleREOptions</a>
makeRegexWith :: (IsRegex re s, Functor m, Monad m, MonadFail m) => SimpleREOptions -> s -> m re

-- | compiling a <a>SearchReplace</a> template from the RE text and the
--   template Text, failing if they are not well formed
makeSearchReplace :: (IsRegex re s, Functor m, Monad m, MonadFail m, IsRegex re s) => s -> s -> m (SearchReplace re s)

-- | compiling a <a>SearchReplace</a> template specifying the
--   <a>SimpleREOptions</a> for the RE
makeSearchReplaceWith :: (IsRegex re s, Functor m, Monad m, MonadFail m, IsRegex re s) => SimpleREOptions -> s -> s -> m (SearchReplace re s)

-- | incorporate an escaped string into a compiled RE with the default
--   options
makeEscaped :: (IsRegex re s, Functor m, Monad m, MonadFail m) => (s -> s) -> s -> m re

-- | incorporate an escaped string into a compiled RE with the specified
--   <a>SimpleREOptions</a>
makeEscapedWith :: (IsRegex re s, Functor m, Monad m, MonadFail m) => SimpleREOptions -> (s -> s) -> s -> m re

-- | extract the text of the RE from the RE
regexSource :: IsRegex re s => re -> s

-- | contains a compiled RE and replacement template
data SearchReplace re s
SearchReplace :: !re -> !s -> SearchReplace re s

-- | the RE to match a string to replace
[getSearch] :: SearchReplace re s -> !re

-- | the replacement template with ${cap} used to identify a capture (by
--   number or name if one was given) and <tt>$$</tt> being used to escape
--   a single <a>$</a>
[getTemplate] :: SearchReplace re s -> !s

-- | search and replace all matches in the argument text; e.g., this
--   function will convert every YYYY-MM-DD format date in its argument
--   text into a DD/MM/YYYY date:
--   
--   <pre>
--   searchReplaceAll [ed|${y}([0-9]{4})-0*${m}([0-9]{2})-0*${d}([0-9]{2})///${d}/${m}/${y}|]
--   </pre>
searchReplaceAll :: IsRegex re s => SearchReplace re s -> s -> s

-- | search and replace the first occurrence only (if any) in the input
--   text e.g., to prefix the first string of four hex digits in the imput
--   text, if any, with <tt>0x</tt>:
--   
--   <pre>
--   searchReplaceFirst [ed|[0-9A-Fa-f]{4}///0x$0|]
--   </pre>
searchReplaceFirst :: IsRegex re s => SearchReplace re s -> s -> s

-- | our line numbers are of the proper zero-based kind
newtype LineNo
ZeroBasedLineNo :: Int -> LineNo
[getZeroBasedLineNo] :: LineNo -> Int

-- | the first line in a file
firstLine :: LineNo

-- | extract a conventional 1-based line number
getLineNo :: LineNo -> Int

-- | inject a conventional 1-based line number
lineNo :: Int -> LineNo

module Text.RE.Tools

-- | read a file, apply an <a>Edits</a> script to each line it and write
--   the file out again; "-" is used to indicate standard input standard
--   output as appropriate
sed :: IsRegex re ByteString => Edits IO re ByteString -> FilePath -> FilePath -> IO ()

-- | apply an <a>Edits</a> script to each line of the argument text
sed' :: (IsRegex re a, Monad m, Functor m) => Edits m re a -> a -> m a

-- | operates a bit like classic <tt>grep</tt> printing out the lines
--   matched
grep :: IsRegex re ByteString => Verbosity -> re -> FilePath -> IO ()

-- | specifies whether to return the lines matched or missed
data Verbosity
LinesMatched :: Verbosity
LinesNotMatched :: Verbosity

-- | <a>grepLines</a> returns a <a>Line</a> for each line in the file,
--   listing all of the <a>Matches</a> for that line
data Line s
Line :: LineNo -> Matches s -> Line s

-- | the <a>LineNo</a> for this line
[getLineNumber] :: Line s -> LineNo

-- | all the <a>Matches</a> of the RE on this line
[getLineMatches] :: Line s -> Matches s

-- | returns a <a>Line</a> for each line in the file, enumerating all of
--   the matches for that line
grepLines :: IsRegex re ByteString => re -> FilePath -> IO [Line ByteString]

-- | returns a <a>Line</a> for each line in the argument text, enumerating
--   all of the matches for that line
grepFilter :: IsRegex re s => re -> s -> [Line s]

-- | a GrepScript lists RE-action associations, with the first RE to match
--   a line selecting the action to be executed on each line in the file
type GrepScript re s t = [(re, LineNo -> Matches s -> Maybe t)]

-- | given a list of lines, apply the <a>GrepScript</a> to each line of the
--   file
grepWithScript :: IsRegex re s => GrepScript re s t -> [s] -> [t]

-- | generate a grep report from a list of <a>Line</a>
report :: Verbosity -> [Line ByteString] -> String

-- | given a <tt>velocity</tt> flag filter out either the lines matched or
--   not matched
linesMatched :: Verbosity -> [Line s] -> [Line s]

-- | a simple regex-based scanner interpreter for prototyping scanners
alex :: IsRegex re s => [(re, Match s -> Maybe t)] -> t -> s -> [t]

-- | a higher order version of <a>alex</a> parameterised over the
--   <tt>matchOnce</tt> function
alex' :: Replace s => (re -> s -> Match s) -> [(re, Match s -> Maybe t)] -> t -> s -> [t]

-- | as we don't want the <tt>directory</tt> and FilePath dependencies we
--   will abstract the three calls we need into this record type
data FindMethods s
FindMethods :: (s -> IO Bool) -> (s -> IO [s]) -> (s -> s -> s) -> FindMethods s

-- | doesDirectoryExist from System.Directory
[doesDirectoryExistDM] :: FindMethods s -> s -> IO Bool

-- | either getDirectoryContents or listDirectory from System.Directory
[listDirectoryDM] :: FindMethods s -> s -> IO [s]

-- | <a>/</a> from System.FilePath
[combineDM] :: FindMethods s -> s -> s -> s

-- | recursively list all files whose filename matches given RE, sorting
--   the list into ascending order; if the argument path has a trailing
--   <a>/</a> then it will be removed
findMatches_ :: IsRegex re s => FindMethods s -> re -> s -> IO [s]

-- | recursively list all files whose filename matches given RE, using the
--   given function to determine which matches to accept
findMatches_' :: IsRegex re s => FindMethods s -> ([s] -> [s]) -> (Match s -> Bool) -> re -> s -> IO [s]

-- | the <a>IsRegex</a> class allows polymorhic tools to be written that
--   will work with a variety of regex back ends and text types
class Replace s => IsRegex re s

-- | finding the first match
matchOnce :: IsRegex re s => re -> s -> Match s

-- | finding all matches
matchMany :: IsRegex re s => re -> s -> Matches s

-- | compiling an RE, failing if the RE is not well formed
makeRegex :: (IsRegex re s, Functor m, Monad m, MonadFail m) => s -> m re

-- | comiling an RE, specifying the <a>SimpleREOptions</a>
makeRegexWith :: (IsRegex re s, Functor m, Monad m, MonadFail m) => SimpleREOptions -> s -> m re

-- | compiling a <a>SearchReplace</a> template from the RE text and the
--   template Text, failing if they are not well formed
makeSearchReplace :: (IsRegex re s, Functor m, Monad m, MonadFail m, IsRegex re s) => s -> s -> m (SearchReplace re s)

-- | compiling a <a>SearchReplace</a> template specifying the
--   <a>SimpleREOptions</a> for the RE
makeSearchReplaceWith :: (IsRegex re s, Functor m, Monad m, MonadFail m, IsRegex re s) => SimpleREOptions -> s -> s -> m (SearchReplace re s)

-- | incorporate an escaped string into a compiled RE with the default
--   options
makeEscaped :: (IsRegex re s, Functor m, Monad m, MonadFail m) => (s -> s) -> s -> m re

-- | incorporate an escaped string into a compiled RE with the specified
--   <a>SimpleREOptions</a>
makeEscapedWith :: (IsRegex re s, Functor m, Monad m, MonadFail m) => SimpleREOptions -> (s -> s) -> s -> m re

-- | extract the text of the RE from the RE
regexSource :: IsRegex re s => re -> s

-- | contains a compiled RE and replacement template
data SearchReplace re s
SearchReplace :: !re -> !s -> SearchReplace re s

-- | the RE to match a string to replace
[getSearch] :: SearchReplace re s -> !re

-- | the replacement template with ${cap} used to identify a capture (by
--   number or name if one was given) and <tt>$$</tt> being used to escape
--   a single <a>$</a>
[getTemplate] :: SearchReplace re s -> !s

-- | search and replace all matches in the argument text; e.g., this
--   function will convert every YYYY-MM-DD format date in its argument
--   text into a DD/MM/YYYY date:
--   
--   <pre>
--   searchReplaceAll [ed|${y}([0-9]{4})-0*${m}([0-9]{2})-0*${d}([0-9]{2})///${d}/${m}/${y}|]
--   </pre>
searchReplaceAll :: IsRegex re s => SearchReplace re s -> s -> s

-- | search and replace the first occurrence only (if any) in the input
--   text e.g., to prefix the first string of four hex digits in the imput
--   text, if any, with <tt>0x</tt>:
--   
--   <pre>
--   searchReplaceFirst [ed|[0-9A-Fa-f]{4}///0x$0|]
--   </pre>
searchReplaceFirst :: IsRegex re s => SearchReplace re s -> s -> s

-- | an <a>Edits</a> script will, for each line in the file, either perform
--   the action selected by the first RE in the list, or perform all of the
--   actions on line, arranged as a pipeline
data Edits m re s

-- | for each line select the first <tt>Edit</tt> to match each line and
--   edit the line with it
Select :: ![Edit m re s] -> Edits m re s

-- | for each line apply every edit that matches in turn to the line
Pipe :: ![Edit m re s] -> Edits m re s

-- | each Edit action specifies how the match should be processed
data Edit m re s

-- | replace the match with this template text, substituting ${capture} as
--   appropriate
Template :: !SearchReplace re s -> Edit m re s

-- | use this function to replace the <a>REContext</a> specified captures
--   in each line matched
Function :: !re -> REContext -> !LineNo -> Match s -> RELocation -> Capture s -> m (Maybe s) -> Edit m re s

-- | use this function to edit each line matched
LineEdit :: !re -> !LineNo -> Matches s -> m (LineEdit s) -> Edit m re s

-- | a LineEdit is the most general action that can be performed on a line
--   and is the only means of deleting a line
data LineEdit s

-- | do not edit this line but leave as is
NoEdit :: LineEdit s

-- | replace the line with this text (terminating newline should not be
--   included)
ReplaceWith :: !s -> LineEdit s

-- | delete the this line altogether
Delete :: LineEdit s

-- | apply an <a>Edit</a> script to a single line
applyEdits :: (IsRegex re s, Monad m, Functor m) => LineNo -> Edits m re s -> s -> m s

-- | apply a single edit action to a line, the function in the first
--   argument being used to add a new line onto the end of the line where
--   appropriate; the function returns <tt>Nothing</tt> if no edit is to be
--   performed on the line, <tt>Just mempty</tt> to delete the line
applyEdit :: (IsRegex re s, Monad m, Functor m) => (s -> s) -> LineNo -> Edit m re s -> s -> m (Maybe s)

-- | apply a <a>Edit</a> to a line, using the function in the first
--   argument to append a new line to the result; Nothing should be
--   returned if no edit is to be performed, <tt>Just mempty</tt> to delete
--   the line
applyLineEdit :: Monoid s => (s -> s) -> LineEdit s -> Maybe s

-- | our line numbers are of the proper zero-based kind
newtype LineNo
ZeroBasedLineNo :: Int -> LineNo
[getZeroBasedLineNo] :: LineNo -> Int

-- | the first line in a file
firstLine :: LineNo

-- | extract a conventional 1-based line number
getLineNo :: LineNo -> Int

-- | inject a conventional 1-based line number
lineNo :: Int -> LineNo

module Text.RE.Summa

module Text.RE.ZeInternals

-- | a hairy dynamically-typed function used with the legacy (=~) and (=~~)
--   to see if it can/should add the capture names extracted from the RE
--   into the polymorphic result of the operator (it does for any Match or
--   Matches type, provided it is parameterised over a recognised type).
--   The test suite is all over this one, testing all of these cases.
addCaptureNames :: Typeable a => CaptureNames -> a -> a

-- | a convenience function used by the API modules to insert capture names
--   extracted from the parsed RE into the (*=~) result
addCaptureNamesToMatches :: CaptureNames -> Matches a -> Matches a

-- | a convenience function used by the API modules to insert capture names
--   extracted from the parsed RE into the (?=~) result
addCaptureNamesToMatch :: CaptureNames -> Match a -> Match a

-- | Convert a string into a regular expression that will match that string
escapeREString :: String -> String

-- | quasi quoter for CaptureID: <tt>[cp|0|]</tt>, <tt>[cp|0|]</tt>, etc.,
--   indexing captures by classic positional numbers, and
--   <tt>[cp|foo|]</tt>, etc., referencing a named capture <tt>[re| ...
--   ${foo}( ... ) ... |]</tt>.
cp :: QuasiQuoter

-- | extract the CaptureNames from an RE or return an error diagnostic if
--   the RE is not well formed; also returns the total number of captures
--   in the RE
extractNamedCaptures :: String -> Either String ((Int, CaptureNames), String)

-- | a configuration that will preserve the parsed regular expression in
--   the output
idFormatTokenREOptions :: FormatTokenREOptions

-- | our RE scanner returns a list of these tokens
data Token

-- | check that a token is well formed
validToken :: Token -> Bool

-- | format [Token] into an RE string
formatTokens :: [Token] -> String

-- | the general Token formatter, generating REs according to the options
formatTokens' :: FormatTokenREOptions -> [Token] -> String
formatTokens0 :: [Token] -> String

-- | scan a RE string into a list of RE Token
scan :: String -> [Token]

-- | expand all of the @{..} macros in the RE in the argument String
--   according to the Macros argument, preprocessing the RE String
--   according to the Mode argument (used internally)
expandMacros :: (r -> String) -> Macros r -> String -> String

-- | an enumeration of all of the prelude macros
data PreludeMacro
PM_nat :: PreludeMacro
PM_hex :: PreludeMacro
PM_int :: PreludeMacro
PM_frac :: PreludeMacro
PM_string :: PreludeMacro
PM_string_simple :: PreludeMacro
PM_id :: PreludeMacro
PM_id' :: PreludeMacro
PM_id_ :: PreludeMacro
PM_date :: PreludeMacro
PM_date_slashes :: PreludeMacro
PM_time :: PreludeMacro
PM_timezone :: PreludeMacro
PM_datetime :: PreludeMacro
PM_datetime_8601 :: PreludeMacro
PM_datetime_clf :: PreludeMacro
PM_shortmonth :: PreludeMacro
PM_address_ipv4 :: PreludeMacro
PM_email_simple :: PreludeMacro
PM_url :: PreludeMacro
PM_syslog_severity :: PreludeMacro

-- | naming the macros
presentPreludeMacro :: PreludeMacro -> String

-- | generate the standard prelude Macros used to parse REs
preludeMacros :: (Monad m, Functor m) => (String -> m r) -> RegexType -> WithCaptures -> m (Macros r)

-- | format the standard prelude macros in a markdown table
preludeMacroTable :: RegexType -> String

-- | generate a textual summary of the prelude macros
preludeMacroSummary :: RegexType -> PreludeMacro -> String

-- | generate a plain text table giving the RE for each macro with all
--   macros expanded (to NF)
preludeMacroSources :: RegexType -> String

-- | generate plain text giving the expanded RE for a single macro
preludeMacroSource :: RegexType -> PreludeMacro -> String

-- | generate the <a>MacroEnv</a> for the standard prelude macros
preludeMacroEnv :: RegexType -> MacroEnv

-- | warapper on <a>compileSearchReplace_</a> that will generate an error
--   if any compilation errors are found
unsafeCompileSearchReplace_ :: (String -> s) -> (String -> Either String re) -> String -> SearchReplace re s

-- | compile a SearchReplace template generating errors if the RE or the
--   template are not well formed -- all capture references being checked
compileSearchReplace_ :: (Monad m, MonadFail m, Functor m) => (String -> s) -> (String -> Either String re) -> String -> m (SearchReplace re s)

-- | compile <tt>SearcgReplace</tt> from two strings containing the RE and
--   the replacement template
compileSearchAndReplace_ :: (Monad m, MonadFail m, Functor m) => (String -> s) -> (String -> Either String re) -> String -> String -> m (SearchReplace re s)

-- | used to throw an exception reporting an abuse of a quasi quoter
data QQFailure
QQFailure :: String -> String -> QQFailure

-- | in what context was the quasi quoter used
[_qqf_context] :: QQFailure -> String

-- | how was the quasi quoter being abused
[_qqf_component] :: QQFailure -> String

-- | a quasi quoter that can be used in no context (to be extended with the
--   appropriate quasi quoter parser)
qq0 :: String -> QuasiQuoter
mkTDFA :: TestBenchMatcher -> RegexType
mkPCRE :: TestBenchMatcher -> RegexType
badMacros :: MacroEnv -> [MacroID]

module Text.RE.TDFA.Text.Lazy

-- | find all the matches in the argument text; e.g., to count the number
--   of naturals in s:
--   
--   <pre>
--   countMatches $ s *=~ [re|[0-9]+|]
--   </pre>
(*=~) :: Text -> RE -> Matches Text

-- | find the first match in the argument text; e.g., to test if there is a
--   natural number in the input text:
--   
--   <pre>
--   matched $ s ?=~ [re|[0-9]+|]
--   </pre>
(?=~) :: Text -> RE -> Match Text

-- | search and replace all matches in the argument text; e.g., this
--   section will convert every YYYY-MM-DD format date in its argument text
--   into a DD/MM/YYYY date:
--   
--   <pre>
--   (*=~/ [ed|${y}([0-9]{4})-0*${m}([0-9]{2})-0*${d}([0-9]{2})///${d}/${m}/${y}|])
--   </pre>
(*=~/) :: Text -> SearchReplace RE Text -> Text

-- | search and replace the first occurrence only (if any) in the input
--   text e.g., to prefix the first string of four hex digits in the input
--   text, if any, with <tt>0x</tt>:
--   
--   <pre>
--   (?=~/ [ed|[0-9A-Fa-f]{4}///0x$0|])
--   </pre>
(?=~/) :: Text -> SearchReplace RE Text -> Text

-- | the result of matching a RE against a text (with <tt>*=~</tt>),
--   retaining the text that was matched against
data Matches a

-- | the source text being matched
matchesSource :: Matches a -> a

-- | all <a>Match</a> instances found, left to right
allMatches :: Matches a -> [Match a]

-- | tests whether the RE matched the source text at all
anyMatches :: Matches a -> Bool

-- | count the matches
countMatches :: Matches a -> Int

-- | list the texts that Matched
matches :: Matches a -> [a]

-- | the result of matching a RE to a text once (with <tt>?=~</tt>),
--   retaining the text that was matched against
data Match a

-- | the whole source text
matchSource :: Match a -> a

-- | tests whether the RE matched the source text at all
matched :: Match a -> Bool

-- | yields the text matched by the RE, Nothing if no match
matchedText :: Match a -> Maybe a

-- | the RE type for this back end representing a well-formed, compiled RE
data RE

-- | extract the RE source string from the <tt>RE</tt>
reSource :: RE -> String

-- | the default API uses these simple, universal RE options, which get
--   auto-converted into the appropriate back-end <a>REOptions_</a>
data SimpleREOptions

-- | case-sensitive with ^ and $ matching the start and end of a line
MultilineSensitive :: SimpleREOptions

-- | case-insensitive with ^ and $ matsh the start and end of a line
MultilineInsensitive :: SimpleREOptions

-- | case-sensitive with ^ and $ matching the start and end of the input
--   text
BlockSensitive :: SimpleREOptions

-- | case-insensitive with ^ and $ matching the start and end of the input
--   text
BlockInsensitive :: SimpleREOptions

-- | contains a compiled RE and replacement template
data SearchReplace re s
SearchReplace :: !re -> !s -> SearchReplace re s

-- | the RE to match a string to replace
[getSearch] :: SearchReplace re s -> !re

-- | the replacement template with ${cap} used to identify a capture (by
--   number or name if one was given) and <tt>$$</tt> being used to escape
--   a single <a>$</a>
[getTemplate] :: SearchReplace re s -> !s

-- | compile a <a>String</a> into a <a>RE</a> with the default options,
--   generating an error if the RE is not well formed
compileRegex :: (Functor m, Monad m, MonadFail m) => String -> m RE

-- | compile a <a>String</a> into a <a>RE</a> using the given
--   <tt>SimpleREOptions</tt>, generating an error if the RE is not well
--   formed
compileRegexWith :: (Functor m, Monad m, MonadFail m) => SimpleREOptions -> String -> m RE

-- | compile a SearchReplace template generating errors if the RE or the
--   template are not well formed, all capture references being checked
compileSearchReplace :: (Monad m, MonadFail m, Functor m, IsRegex RE s) => String -> String -> m (SearchReplace RE s)

-- | compile a SearchReplace template, with simple options, generating
--   errors if the RE or the template are not well formed, all capture
--   references being checked
compileSearchReplaceWith :: (Monad m, MonadFail m, Functor m, IsRegex RE s) => SimpleREOptions -> String -> String -> m (SearchReplace RE s)

-- | convert a string into a RE that matches that string, and apply it to
--   an argument continuation function to make up the RE string to be
--   compiled; e.g., to compile a RE that will only match the string:
--   
--   <pre>
--   maybe undefined id . escape (("^"++) . (++"$"))
--   </pre>
escape :: (Functor m, Monad m, MonadFail m) => (String -> String) -> String -> m RE

-- | a variant of <a>escape</a> where the <a>SimpleREOptions</a> are
--   specified
escapeWith :: (Functor m, Monad m, MonadFail m) => SimpleREOptions -> (String -> String) -> String -> m RE

-- | Convert a string into a regular expression that will match that string
escapeREString :: String -> String

-- | the `regex-base` polymorphic match operator
(=~) :: (Typeable a, RegexContext Regex Text a) => Text -> RE -> a

-- | the `regex-base` monadic, polymorphic match operator
(=~~) :: (Monad m, MonadFail m, Functor m, Typeable a, RegexContext Regex Text a) => Text -> RE -> m a

-- | <tt>[re| ... |]</tt>, is equivalent to <tt>[reMultilineSensitive| ...
--   |]</tt>, compiling a case-sensitive, multi-line RE
re :: QuasiQuoter

-- | <tt>[reMultilineSensitive| ... |]</tt>, compiles a case-sensitive,
--   multi-line RE
reMultilineSensitive :: QuasiQuoter

-- | <tt>[reMultilineInsensitive| ... |]</tt>, compiles a case-insensitive,
--   multi-line RE
reMultilineInsensitive :: QuasiQuoter

-- | <tt>[reMultilineInsensitive| ... |]</tt>, compiles a case-sensitive,
--   non-multi-line RE
reBlockSensitive :: QuasiQuoter

-- | <tt>[reMultilineInsensitive| ... |]</tt>, compiles a case-insensitive,
--   non-multi-line RE
reBlockInsensitive :: QuasiQuoter

-- | <tt>[reMS| ... |]</tt> is a shorthand for <tt>[reMultilineSensitive|
--   ... |]</tt>
reMS :: QuasiQuoter

-- | <tt>[reMI| ... |]</tt> is a shorthand for <tt>[reMultilineInsensitive|
--   ... |]</tt>
reMI :: QuasiQuoter

-- | <tt>[reBS| ... |]</tt> is a shorthand for <tt>[reBlockSensitive| ...
--   |]</tt>
reBS :: QuasiQuoter

-- | <tt>[reBI| ... |]</tt> is a shorthand for <tt>[reBlockInsensitive| ...
--   |]</tt>
reBI :: QuasiQuoter

-- | <tt>[re_| ... |]</tt> compiles a RE to produce a function that takes
--   the RE options (e.g., a <a>SimpleREOptions</a> value) and yields the
--   RE compiled with those options. For example,
--   
--   <pre>
--   countMatches $ s *=~ [re_|[0-9a-f]+|] MultilineInsensitive
--   </pre>
--   
--   counts the number of hexadecimal digit strings in <tt>s</tt>, allowing
--   for upper- or lower-case hex digits (which is entirely equivalent in
--   this example to just using
--   <tt>[reMultilineInsensitive|[0-9a-f]+|]</tt>).
re_ :: QuasiQuoter

-- | <tt>[edMultilineSensitive| ... /// ... |]</tt> compiles a
--   case-sensitive, multi-line <a>SearchReplace</a> template
edMultilineSensitive :: QuasiQuoter

-- | <tt>[edMultilineInsensitive| ... /// ... |]</tt> compiles a
--   case-insensitive, multi-line <a>SearchReplace</a> template
edMultilineInsensitive :: QuasiQuoter

-- | <tt>[edBlockSensitive| ... /// ... |]</tt> compiles a case-sensitive,
--   non-multi-line <a>SearchReplace</a> template
edBlockSensitive :: QuasiQuoter

-- | <tt>[edBlockInsensitive| ... /// ... |]</tt> compiles a
--   case-insensitive, non-multi-line <a>SearchReplace</a> template
edBlockInsensitive :: QuasiQuoter

-- | <tt>[ed| ... /// ... |]</tt>, is equivalent to
--   <tt>[edMultilineSensitive| ... /// ... |]</tt>, compiling a
--   case-sensitive, multi-line <a>SearchReplace</a>
ed :: QuasiQuoter

-- | <tt>[edMS| ... /// ... |]</tt> is a shorthand for
--   <tt>[edMultilineSensitive| ... /// ... |]</tt>
edMS :: QuasiQuoter

-- | <tt>[edMI| ... /// ... |]</tt> is a shorthand for
--   <tt>[edMultilineInsensitive| ... /// ... |]</tt>
edMI :: QuasiQuoter

-- | <tt>[edBS| ... /// ... |]</tt> is a shorthand for
--   <tt>[edBlockSensitive| ... /// ... |]</tt>
edBS :: QuasiQuoter

-- | <tt>[edBI| ... /// ... |]</tt> is a shorthand for
--   <tt>[edBlockInsensitive| ... /// ... |]</tt>
edBI :: QuasiQuoter

-- | <tt>[ed_| ... /// ... |]</tt> compiles a <a>SearchReplace</a> template
--   to produce a function that takes the RE options (e.g., a
--   <a>SimpleREOptions</a> value) and yields the <a>SearchReplace</a>
--   template compiled with those options. For example,
--   
--   <pre>
--   s *=~/ [ed_|${hex}([0-9a-f]+)///0x${hex}|] MultilineInsensitive
--   </pre>
--   
--   prefixes the hexadecimal digit strings in s with <tt>0x</tt>, allowing
--   for upper- or lower-case hex digits (which is entirely equivalent in
--   this example to just using
--   <tt>[edMultilineInsensitive|[0-9a-f]+|]</tt>).
ed_ :: QuasiQuoter

-- | quasi quoter for CaptureID: <tt>[cp|0|]</tt>, <tt>[cp|0|]</tt>, etc.,
--   indexing captures by classic positional numbers, and
--   <tt>[cp|foo|]</tt>, etc., referencing a named capture <tt>[re| ...
--   ${foo}( ... ) ... |]</tt>.
cp :: QuasiQuoter
instance Text.RE.ZeInternals.Types.IsRegex.IsRegex Text.RE.ZeInternals.TDFA.RE Data.Text.Internal.Lazy.Text

module Text.RE.TDFA.Text

-- | find all the matches in the argument text; e.g., to count the number
--   of naturals in s:
--   
--   <pre>
--   countMatches $ s *=~ [re|[0-9]+|]
--   </pre>
(*=~) :: Text -> RE -> Matches Text

-- | find the first match in the argument text; e.g., to test if there is a
--   natural number in the input text:
--   
--   <pre>
--   matched $ s ?=~ [re|[0-9]+|]
--   </pre>
(?=~) :: Text -> RE -> Match Text

-- | search and replace all matches in the argument text; e.g., this
--   section will convert every YYYY-MM-DD format date in its argument text
--   into a DD/MM/YYYY date:
--   
--   <pre>
--   (*=~/ [ed|${y}([0-9]{4})-0*${m}([0-9]{2})-0*${d}([0-9]{2})///${d}/${m}/${y}|])
--   </pre>
(*=~/) :: Text -> SearchReplace RE Text -> Text

-- | search and replace the first occurrence only (if any) in the input
--   text e.g., to prefix the first string of four hex digits in the input
--   text, if any, with <tt>0x</tt>:
--   
--   <pre>
--   (?=~/ [ed|[0-9A-Fa-f]{4}///0x$0|])
--   </pre>
(?=~/) :: Text -> SearchReplace RE Text -> Text

-- | the result of matching a RE against a text (with <tt>*=~</tt>),
--   retaining the text that was matched against
data Matches a

-- | the source text being matched
matchesSource :: Matches a -> a

-- | all <a>Match</a> instances found, left to right
allMatches :: Matches a -> [Match a]

-- | tests whether the RE matched the source text at all
anyMatches :: Matches a -> Bool

-- | count the matches
countMatches :: Matches a -> Int

-- | list the texts that Matched
matches :: Matches a -> [a]

-- | the result of matching a RE to a text once (with <tt>?=~</tt>),
--   retaining the text that was matched against
data Match a

-- | the whole source text
matchSource :: Match a -> a

-- | tests whether the RE matched the source text at all
matched :: Match a -> Bool

-- | yields the text matched by the RE, Nothing if no match
matchedText :: Match a -> Maybe a

-- | the RE type for this back end representing a well-formed, compiled RE
data RE

-- | extract the RE source string from the <tt>RE</tt>
reSource :: RE -> String

-- | the default API uses these simple, universal RE options, which get
--   auto-converted into the appropriate back-end <a>REOptions_</a>
data SimpleREOptions

-- | case-sensitive with ^ and $ matching the start and end of a line
MultilineSensitive :: SimpleREOptions

-- | case-insensitive with ^ and $ matsh the start and end of a line
MultilineInsensitive :: SimpleREOptions

-- | case-sensitive with ^ and $ matching the start and end of the input
--   text
BlockSensitive :: SimpleREOptions

-- | case-insensitive with ^ and $ matching the start and end of the input
--   text
BlockInsensitive :: SimpleREOptions

-- | contains a compiled RE and replacement template
data SearchReplace re s
SearchReplace :: !re -> !s -> SearchReplace re s

-- | the RE to match a string to replace
[getSearch] :: SearchReplace re s -> !re

-- | the replacement template with ${cap} used to identify a capture (by
--   number or name if one was given) and <tt>$$</tt> being used to escape
--   a single <a>$</a>
[getTemplate] :: SearchReplace re s -> !s

-- | compile a <a>String</a> into a <a>RE</a> with the default options,
--   generating an error if the RE is not well formed
compileRegex :: (Functor m, Monad m, MonadFail m) => String -> m RE

-- | compile a <a>String</a> into a <a>RE</a> using the given
--   <tt>SimpleREOptions</tt>, generating an error if the RE is not well
--   formed
compileRegexWith :: (Functor m, Monad m, MonadFail m) => SimpleREOptions -> String -> m RE

-- | compile a SearchReplace template generating errors if the RE or the
--   template are not well formed, all capture references being checked
compileSearchReplace :: (Monad m, MonadFail m, Functor m, IsRegex RE s) => String -> String -> m (SearchReplace RE s)

-- | compile a SearchReplace template, with simple options, generating
--   errors if the RE or the template are not well formed, all capture
--   references being checked
compileSearchReplaceWith :: (Monad m, MonadFail m, Functor m, IsRegex RE s) => SimpleREOptions -> String -> String -> m (SearchReplace RE s)

-- | convert a string into a RE that matches that string, and apply it to
--   an argument continuation function to make up the RE string to be
--   compiled; e.g., to compile a RE that will only match the string:
--   
--   <pre>
--   maybe undefined id . escape (("^"++) . (++"$"))
--   </pre>
escape :: (Functor m, Monad m, MonadFail m) => (String -> String) -> String -> m RE

-- | a variant of <a>escape</a> where the <a>SimpleREOptions</a> are
--   specified
escapeWith :: (Functor m, Monad m, MonadFail m) => SimpleREOptions -> (String -> String) -> String -> m RE

-- | Convert a string into a regular expression that will match that string
escapeREString :: String -> String

-- | the `regex-base` polymorphic match operator
(=~) :: (Typeable a, RegexContext Regex Text a) => Text -> RE -> a

-- | the `regex-base` monadic, polymorphic match operator
(=~~) :: (Monad m, MonadFail m, Functor m, Typeable a, RegexContext Regex Text a) => Text -> RE -> m a

-- | <tt>[re| ... |]</tt>, is equivalent to <tt>[reMultilineSensitive| ...
--   |]</tt>, compiling a case-sensitive, multi-line RE
re :: QuasiQuoter

-- | <tt>[reMultilineSensitive| ... |]</tt>, compiles a case-sensitive,
--   multi-line RE
reMultilineSensitive :: QuasiQuoter

-- | <tt>[reMultilineInsensitive| ... |]</tt>, compiles a case-insensitive,
--   multi-line RE
reMultilineInsensitive :: QuasiQuoter

-- | <tt>[reMultilineInsensitive| ... |]</tt>, compiles a case-sensitive,
--   non-multi-line RE
reBlockSensitive :: QuasiQuoter

-- | <tt>[reMultilineInsensitive| ... |]</tt>, compiles a case-insensitive,
--   non-multi-line RE
reBlockInsensitive :: QuasiQuoter

-- | <tt>[reMS| ... |]</tt> is a shorthand for <tt>[reMultilineSensitive|
--   ... |]</tt>
reMS :: QuasiQuoter

-- | <tt>[reMI| ... |]</tt> is a shorthand for <tt>[reMultilineInsensitive|
--   ... |]</tt>
reMI :: QuasiQuoter

-- | <tt>[reBS| ... |]</tt> is a shorthand for <tt>[reBlockSensitive| ...
--   |]</tt>
reBS :: QuasiQuoter

-- | <tt>[reBI| ... |]</tt> is a shorthand for <tt>[reBlockInsensitive| ...
--   |]</tt>
reBI :: QuasiQuoter

-- | <tt>[re_| ... |]</tt> compiles a RE to produce a function that takes
--   the RE options (e.g., a <a>SimpleREOptions</a> value) and yields the
--   RE compiled with those options. For example,
--   
--   <pre>
--   countMatches $ s *=~ [re_|[0-9a-f]+|] MultilineInsensitive
--   </pre>
--   
--   counts the number of hexadecimal digit strings in <tt>s</tt>, allowing
--   for upper- or lower-case hex digits (which is entirely equivalent in
--   this example to just using
--   <tt>[reMultilineInsensitive|[0-9a-f]+|]</tt>).
re_ :: QuasiQuoter

-- | <tt>[edMultilineSensitive| ... /// ... |]</tt> compiles a
--   case-sensitive, multi-line <a>SearchReplace</a> template
edMultilineSensitive :: QuasiQuoter

-- | <tt>[edMultilineInsensitive| ... /// ... |]</tt> compiles a
--   case-insensitive, multi-line <a>SearchReplace</a> template
edMultilineInsensitive :: QuasiQuoter

-- | <tt>[edBlockSensitive| ... /// ... |]</tt> compiles a case-sensitive,
--   non-multi-line <a>SearchReplace</a> template
edBlockSensitive :: QuasiQuoter

-- | <tt>[edBlockInsensitive| ... /// ... |]</tt> compiles a
--   case-insensitive, non-multi-line <a>SearchReplace</a> template
edBlockInsensitive :: QuasiQuoter

-- | <tt>[ed| ... /// ... |]</tt>, is equivalent to
--   <tt>[edMultilineSensitive| ... /// ... |]</tt>, compiling a
--   case-sensitive, multi-line <a>SearchReplace</a>
ed :: QuasiQuoter

-- | <tt>[edMS| ... /// ... |]</tt> is a shorthand for
--   <tt>[edMultilineSensitive| ... /// ... |]</tt>
edMS :: QuasiQuoter

-- | <tt>[edMI| ... /// ... |]</tt> is a shorthand for
--   <tt>[edMultilineInsensitive| ... /// ... |]</tt>
edMI :: QuasiQuoter

-- | <tt>[edBS| ... /// ... |]</tt> is a shorthand for
--   <tt>[edBlockSensitive| ... /// ... |]</tt>
edBS :: QuasiQuoter

-- | <tt>[edBI| ... /// ... |]</tt> is a shorthand for
--   <tt>[edBlockInsensitive| ... /// ... |]</tt>
edBI :: QuasiQuoter

-- | <tt>[ed_| ... /// ... |]</tt> compiles a <a>SearchReplace</a> template
--   to produce a function that takes the RE options (e.g., a
--   <a>SimpleREOptions</a> value) and yields the <a>SearchReplace</a>
--   template compiled with those options. For example,
--   
--   <pre>
--   s *=~/ [ed_|${hex}([0-9a-f]+)///0x${hex}|] MultilineInsensitive
--   </pre>
--   
--   prefixes the hexadecimal digit strings in s with <tt>0x</tt>, allowing
--   for upper- or lower-case hex digits (which is entirely equivalent in
--   this example to just using
--   <tt>[edMultilineInsensitive|[0-9a-f]+|]</tt>).
ed_ :: QuasiQuoter

-- | quasi quoter for CaptureID: <tt>[cp|0|]</tt>, <tt>[cp|0|]</tt>, etc.,
--   indexing captures by classic positional numbers, and
--   <tt>[cp|foo|]</tt>, etc., referencing a named capture <tt>[re| ...
--   ${foo}( ... ) ... |]</tt>.
cp :: QuasiQuoter
instance Text.RE.ZeInternals.Types.IsRegex.IsRegex Text.RE.ZeInternals.TDFA.RE Data.Text.Internal.Text

module Text.RE.TDFA.String

-- | find all the matches in the argument text; e.g., to count the number
--   of naturals in s:
--   
--   <pre>
--   countMatches $ s *=~ [re|[0-9]+|]
--   </pre>
(*=~) :: String -> RE -> Matches String

-- | find the first match in the argument text; e.g., to test if there is a
--   natural number in the input text:
--   
--   <pre>
--   matched $ s ?=~ [re|[0-9]+|]
--   </pre>
(?=~) :: String -> RE -> Match String

-- | search and replace all matches in the argument text; e.g., this
--   section will convert every YYYY-MM-DD format date in its argument text
--   into a DD/MM/YYYY date:
--   
--   <pre>
--   (*=~/ [ed|${y}([0-9]{4})-0*${m}([0-9]{2})-0*${d}([0-9]{2})///${d}/${m}/${y}|])
--   </pre>
(*=~/) :: String -> SearchReplace RE String -> String

-- | search and replace the first occurrence only (if any) in the input
--   text e.g., to prefix the first string of four hex digits in the input
--   text, if any, with <tt>0x</tt>:
--   
--   <pre>
--   (?=~/ [ed|[0-9A-Fa-f]{4}///0x$0|])
--   </pre>
(?=~/) :: String -> SearchReplace RE String -> String

-- | the result of matching a RE against a text (with <tt>*=~</tt>),
--   retaining the text that was matched against
data Matches a

-- | the source text being matched
matchesSource :: Matches a -> a

-- | all <a>Match</a> instances found, left to right
allMatches :: Matches a -> [Match a]

-- | tests whether the RE matched the source text at all
anyMatches :: Matches a -> Bool

-- | count the matches
countMatches :: Matches a -> Int

-- | list the texts that Matched
matches :: Matches a -> [a]

-- | the result of matching a RE to a text once (with <tt>?=~</tt>),
--   retaining the text that was matched against
data Match a

-- | the whole source text
matchSource :: Match a -> a

-- | tests whether the RE matched the source text at all
matched :: Match a -> Bool

-- | yields the text matched by the RE, Nothing if no match
matchedText :: Match a -> Maybe a

-- | the RE type for this back end representing a well-formed, compiled RE
data RE

-- | extract the RE source string from the <tt>RE</tt>
reSource :: RE -> String

-- | the default API uses these simple, universal RE options, which get
--   auto-converted into the appropriate back-end <a>REOptions_</a>
data SimpleREOptions

-- | case-sensitive with ^ and $ matching the start and end of a line
MultilineSensitive :: SimpleREOptions

-- | case-insensitive with ^ and $ matsh the start and end of a line
MultilineInsensitive :: SimpleREOptions

-- | case-sensitive with ^ and $ matching the start and end of the input
--   text
BlockSensitive :: SimpleREOptions

-- | case-insensitive with ^ and $ matching the start and end of the input
--   text
BlockInsensitive :: SimpleREOptions

-- | contains a compiled RE and replacement template
data SearchReplace re s
SearchReplace :: !re -> !s -> SearchReplace re s

-- | the RE to match a string to replace
[getSearch] :: SearchReplace re s -> !re

-- | the replacement template with ${cap} used to identify a capture (by
--   number or name if one was given) and <tt>$$</tt> being used to escape
--   a single <a>$</a>
[getTemplate] :: SearchReplace re s -> !s

-- | compile a <a>String</a> into a <a>RE</a> with the default options,
--   generating an error if the RE is not well formed
compileRegex :: (Functor m, Monad m, MonadFail m) => String -> m RE

-- | compile a <a>String</a> into a <a>RE</a> using the given
--   <tt>SimpleREOptions</tt>, generating an error if the RE is not well
--   formed
compileRegexWith :: (Functor m, Monad m, MonadFail m) => SimpleREOptions -> String -> m RE

-- | compile a SearchReplace template generating errors if the RE or the
--   template are not well formed, all capture references being checked
compileSearchReplace :: (Monad m, MonadFail m, Functor m, IsRegex RE s) => String -> String -> m (SearchReplace RE s)

-- | compile a SearchReplace template, with simple options, generating
--   errors if the RE or the template are not well formed, all capture
--   references being checked
compileSearchReplaceWith :: (Monad m, MonadFail m, Functor m, IsRegex RE s) => SimpleREOptions -> String -> String -> m (SearchReplace RE s)

-- | convert a string into a RE that matches that string, and apply it to
--   an argument continuation function to make up the RE string to be
--   compiled; e.g., to compile a RE that will only match the string:
--   
--   <pre>
--   maybe undefined id . escape (("^"++) . (++"$"))
--   </pre>
escape :: (Functor m, Monad m, MonadFail m) => (String -> String) -> String -> m RE

-- | a variant of <a>escape</a> where the <a>SimpleREOptions</a> are
--   specified
escapeWith :: (Functor m, Monad m, MonadFail m) => SimpleREOptions -> (String -> String) -> String -> m RE

-- | Convert a string into a regular expression that will match that string
escapeREString :: String -> String

-- | the `regex-base` polymorphic match operator
(=~) :: (Typeable a, RegexContext Regex String a) => String -> RE -> a

-- | the `regex-base` monadic, polymorphic match operator
(=~~) :: (Monad m, MonadFail m, Functor m, Typeable a, RegexContext Regex String a) => String -> RE -> m a

-- | <tt>[re| ... |]</tt>, is equivalent to <tt>[reMultilineSensitive| ...
--   |]</tt>, compiling a case-sensitive, multi-line RE
re :: QuasiQuoter

-- | <tt>[reMultilineSensitive| ... |]</tt>, compiles a case-sensitive,
--   multi-line RE
reMultilineSensitive :: QuasiQuoter

-- | <tt>[reMultilineInsensitive| ... |]</tt>, compiles a case-insensitive,
--   multi-line RE
reMultilineInsensitive :: QuasiQuoter

-- | <tt>[reMultilineInsensitive| ... |]</tt>, compiles a case-sensitive,
--   non-multi-line RE
reBlockSensitive :: QuasiQuoter

-- | <tt>[reMultilineInsensitive| ... |]</tt>, compiles a case-insensitive,
--   non-multi-line RE
reBlockInsensitive :: QuasiQuoter

-- | <tt>[reMS| ... |]</tt> is a shorthand for <tt>[reMultilineSensitive|
--   ... |]</tt>
reMS :: QuasiQuoter

-- | <tt>[reMI| ... |]</tt> is a shorthand for <tt>[reMultilineInsensitive|
--   ... |]</tt>
reMI :: QuasiQuoter

-- | <tt>[reBS| ... |]</tt> is a shorthand for <tt>[reBlockSensitive| ...
--   |]</tt>
reBS :: QuasiQuoter

-- | <tt>[reBI| ... |]</tt> is a shorthand for <tt>[reBlockInsensitive| ...
--   |]</tt>
reBI :: QuasiQuoter

-- | <tt>[re_| ... |]</tt> compiles a RE to produce a function that takes
--   the RE options (e.g., a <a>SimpleREOptions</a> value) and yields the
--   RE compiled with those options. For example,
--   
--   <pre>
--   countMatches $ s *=~ [re_|[0-9a-f]+|] MultilineInsensitive
--   </pre>
--   
--   counts the number of hexadecimal digit strings in <tt>s</tt>, allowing
--   for upper- or lower-case hex digits (which is entirely equivalent in
--   this example to just using
--   <tt>[reMultilineInsensitive|[0-9a-f]+|]</tt>).
re_ :: QuasiQuoter

-- | <tt>[edMultilineSensitive| ... /// ... |]</tt> compiles a
--   case-sensitive, multi-line <a>SearchReplace</a> template
edMultilineSensitive :: QuasiQuoter

-- | <tt>[edMultilineInsensitive| ... /// ... |]</tt> compiles a
--   case-insensitive, multi-line <a>SearchReplace</a> template
edMultilineInsensitive :: QuasiQuoter

-- | <tt>[edBlockSensitive| ... /// ... |]</tt> compiles a case-sensitive,
--   non-multi-line <a>SearchReplace</a> template
edBlockSensitive :: QuasiQuoter

-- | <tt>[edBlockInsensitive| ... /// ... |]</tt> compiles a
--   case-insensitive, non-multi-line <a>SearchReplace</a> template
edBlockInsensitive :: QuasiQuoter

-- | <tt>[ed| ... /// ... |]</tt>, is equivalent to
--   <tt>[edMultilineSensitive| ... /// ... |]</tt>, compiling a
--   case-sensitive, multi-line <a>SearchReplace</a>
ed :: QuasiQuoter

-- | <tt>[edMS| ... /// ... |]</tt> is a shorthand for
--   <tt>[edMultilineSensitive| ... /// ... |]</tt>
edMS :: QuasiQuoter

-- | <tt>[edMI| ... /// ... |]</tt> is a shorthand for
--   <tt>[edMultilineInsensitive| ... /// ... |]</tt>
edMI :: QuasiQuoter

-- | <tt>[edBS| ... /// ... |]</tt> is a shorthand for
--   <tt>[edBlockSensitive| ... /// ... |]</tt>
edBS :: QuasiQuoter

-- | <tt>[edBI| ... /// ... |]</tt> is a shorthand for
--   <tt>[edBlockInsensitive| ... /// ... |]</tt>
edBI :: QuasiQuoter

-- | <tt>[ed_| ... /// ... |]</tt> compiles a <a>SearchReplace</a> template
--   to produce a function that takes the RE options (e.g., a
--   <a>SimpleREOptions</a> value) and yields the <a>SearchReplace</a>
--   template compiled with those options. For example,
--   
--   <pre>
--   s *=~/ [ed_|${hex}([0-9a-f]+)///0x${hex}|] MultilineInsensitive
--   </pre>
--   
--   prefixes the hexadecimal digit strings in s with <tt>0x</tt>, allowing
--   for upper- or lower-case hex digits (which is entirely equivalent in
--   this example to just using
--   <tt>[edMultilineInsensitive|[0-9a-f]+|]</tt>).
ed_ :: QuasiQuoter

-- | quasi quoter for CaptureID: <tt>[cp|0|]</tt>, <tt>[cp|0|]</tt>, etc.,
--   indexing captures by classic positional numbers, and
--   <tt>[cp|foo|]</tt>, etc., referencing a named capture <tt>[re| ...
--   ${foo}( ... ) ... |]</tt>.
cp :: QuasiQuoter
instance Text.RE.ZeInternals.Types.IsRegex.IsRegex Text.RE.ZeInternals.TDFA.RE GHC.Base.String

module Text.RE.TDFA.Sequence

-- | find all the matches in the argument text; e.g., to count the number
--   of naturals in s:
--   
--   <pre>
--   countMatches $ s *=~ [re|[0-9]+|]
--   </pre>
(*=~) :: Seq Char -> RE -> Matches (Seq Char)

-- | find the first match in the argument text; e.g., to test if there is a
--   natural number in the input text:
--   
--   <pre>
--   matched $ s ?=~ [re|[0-9]+|]
--   </pre>
(?=~) :: Seq Char -> RE -> Match (Seq Char)

-- | search and replace all matches in the argument text; e.g., this
--   section will convert every YYYY-MM-DD format date in its argument text
--   into a DD/MM/YYYY date:
--   
--   <pre>
--   (*=~/ [ed|${y}([0-9]{4})-0*${m}([0-9]{2})-0*${d}([0-9]{2})///${d}/${m}/${y}|])
--   </pre>
(*=~/) :: Seq Char -> SearchReplace RE (Seq Char) -> Seq Char

-- | search and replace the first occurrence only (if any) in the input
--   text e.g., to prefix the first string of four hex digits in the input
--   text, if any, with <tt>0x</tt>:
--   
--   <pre>
--   (?=~/ [ed|[0-9A-Fa-f]{4}///0x$0|])
--   </pre>
(?=~/) :: Seq Char -> SearchReplace RE (Seq Char) -> Seq Char

-- | the result of matching a RE against a text (with <tt>*=~</tt>),
--   retaining the text that was matched against
data Matches a

-- | the source text being matched
matchesSource :: Matches a -> a

-- | all <a>Match</a> instances found, left to right
allMatches :: Matches a -> [Match a]

-- | tests whether the RE matched the source text at all
anyMatches :: Matches a -> Bool

-- | count the matches
countMatches :: Matches a -> Int

-- | list the texts that Matched
matches :: Matches a -> [a]

-- | the result of matching a RE to a text once (with <tt>?=~</tt>),
--   retaining the text that was matched against
data Match a

-- | the whole source text
matchSource :: Match a -> a

-- | tests whether the RE matched the source text at all
matched :: Match a -> Bool

-- | yields the text matched by the RE, Nothing if no match
matchedText :: Match a -> Maybe a

-- | the RE type for this back end representing a well-formed, compiled RE
data RE

-- | extract the RE source string from the <tt>RE</tt>
reSource :: RE -> String

-- | the default API uses these simple, universal RE options, which get
--   auto-converted into the appropriate back-end <a>REOptions_</a>
data SimpleREOptions

-- | case-sensitive with ^ and $ matching the start and end of a line
MultilineSensitive :: SimpleREOptions

-- | case-insensitive with ^ and $ matsh the start and end of a line
MultilineInsensitive :: SimpleREOptions

-- | case-sensitive with ^ and $ matching the start and end of the input
--   text
BlockSensitive :: SimpleREOptions

-- | case-insensitive with ^ and $ matching the start and end of the input
--   text
BlockInsensitive :: SimpleREOptions

-- | contains a compiled RE and replacement template
data SearchReplace re s
SearchReplace :: !re -> !s -> SearchReplace re s

-- | the RE to match a string to replace
[getSearch] :: SearchReplace re s -> !re

-- | the replacement template with ${cap} used to identify a capture (by
--   number or name if one was given) and <tt>$$</tt> being used to escape
--   a single <a>$</a>
[getTemplate] :: SearchReplace re s -> !s

-- | compile a <a>String</a> into a <a>RE</a> with the default options,
--   generating an error if the RE is not well formed
compileRegex :: (Functor m, Monad m, MonadFail m) => String -> m RE

-- | compile a <a>String</a> into a <a>RE</a> using the given
--   <tt>SimpleREOptions</tt>, generating an error if the RE is not well
--   formed
compileRegexWith :: (Functor m, Monad m, MonadFail m) => SimpleREOptions -> String -> m RE

-- | compile a SearchReplace template generating errors if the RE or the
--   template are not well formed, all capture references being checked
compileSearchReplace :: (Monad m, MonadFail m, Functor m, IsRegex RE s) => String -> String -> m (SearchReplace RE s)

-- | compile a SearchReplace template, with simple options, generating
--   errors if the RE or the template are not well formed, all capture
--   references being checked
compileSearchReplaceWith :: (Monad m, MonadFail m, Functor m, IsRegex RE s) => SimpleREOptions -> String -> String -> m (SearchReplace RE s)

-- | convert a string into a RE that matches that string, and apply it to
--   an argument continuation function to make up the RE string to be
--   compiled; e.g., to compile a RE that will only match the string:
--   
--   <pre>
--   maybe undefined id . escape (("^"++) . (++"$"))
--   </pre>
escape :: (Functor m, Monad m, MonadFail m) => (String -> String) -> String -> m RE

-- | a variant of <a>escape</a> where the <a>SimpleREOptions</a> are
--   specified
escapeWith :: (Functor m, Monad m, MonadFail m) => SimpleREOptions -> (String -> String) -> String -> m RE

-- | Convert a string into a regular expression that will match that string
escapeREString :: String -> String

-- | the `regex-base` polymorphic match operator
(=~) :: (Typeable a, RegexContext Regex (Seq Char) a) => Seq Char -> RE -> a

-- | the `regex-base` monadic, polymorphic match operator
(=~~) :: (Monad m, MonadFail m, Functor m, Typeable a, RegexContext Regex (Seq Char) a) => Seq Char -> RE -> m a

-- | <tt>[re| ... |]</tt>, is equivalent to <tt>[reMultilineSensitive| ...
--   |]</tt>, compiling a case-sensitive, multi-line RE
re :: QuasiQuoter

-- | <tt>[reMultilineSensitive| ... |]</tt>, compiles a case-sensitive,
--   multi-line RE
reMultilineSensitive :: QuasiQuoter

-- | <tt>[reMultilineInsensitive| ... |]</tt>, compiles a case-insensitive,
--   multi-line RE
reMultilineInsensitive :: QuasiQuoter

-- | <tt>[reMultilineInsensitive| ... |]</tt>, compiles a case-sensitive,
--   non-multi-line RE
reBlockSensitive :: QuasiQuoter

-- | <tt>[reMultilineInsensitive| ... |]</tt>, compiles a case-insensitive,
--   non-multi-line RE
reBlockInsensitive :: QuasiQuoter

-- | <tt>[reMS| ... |]</tt> is a shorthand for <tt>[reMultilineSensitive|
--   ... |]</tt>
reMS :: QuasiQuoter

-- | <tt>[reMI| ... |]</tt> is a shorthand for <tt>[reMultilineInsensitive|
--   ... |]</tt>
reMI :: QuasiQuoter

-- | <tt>[reBS| ... |]</tt> is a shorthand for <tt>[reBlockSensitive| ...
--   |]</tt>
reBS :: QuasiQuoter

-- | <tt>[reBI| ... |]</tt> is a shorthand for <tt>[reBlockInsensitive| ...
--   |]</tt>
reBI :: QuasiQuoter

-- | <tt>[re_| ... |]</tt> compiles a RE to produce a function that takes
--   the RE options (e.g., a <a>SimpleREOptions</a> value) and yields the
--   RE compiled with those options. For example,
--   
--   <pre>
--   countMatches $ s *=~ [re_|[0-9a-f]+|] MultilineInsensitive
--   </pre>
--   
--   counts the number of hexadecimal digit strings in <tt>s</tt>, allowing
--   for upper- or lower-case hex digits (which is entirely equivalent in
--   this example to just using
--   <tt>[reMultilineInsensitive|[0-9a-f]+|]</tt>).
re_ :: QuasiQuoter

-- | <tt>[edMultilineSensitive| ... /// ... |]</tt> compiles a
--   case-sensitive, multi-line <a>SearchReplace</a> template
edMultilineSensitive :: QuasiQuoter

-- | <tt>[edMultilineInsensitive| ... /// ... |]</tt> compiles a
--   case-insensitive, multi-line <a>SearchReplace</a> template
edMultilineInsensitive :: QuasiQuoter

-- | <tt>[edBlockSensitive| ... /// ... |]</tt> compiles a case-sensitive,
--   non-multi-line <a>SearchReplace</a> template
edBlockSensitive :: QuasiQuoter

-- | <tt>[edBlockInsensitive| ... /// ... |]</tt> compiles a
--   case-insensitive, non-multi-line <a>SearchReplace</a> template
edBlockInsensitive :: QuasiQuoter

-- | <tt>[ed| ... /// ... |]</tt>, is equivalent to
--   <tt>[edMultilineSensitive| ... /// ... |]</tt>, compiling a
--   case-sensitive, multi-line <a>SearchReplace</a>
ed :: QuasiQuoter

-- | <tt>[edMS| ... /// ... |]</tt> is a shorthand for
--   <tt>[edMultilineSensitive| ... /// ... |]</tt>
edMS :: QuasiQuoter

-- | <tt>[edMI| ... /// ... |]</tt> is a shorthand for
--   <tt>[edMultilineInsensitive| ... /// ... |]</tt>
edMI :: QuasiQuoter

-- | <tt>[edBS| ... /// ... |]</tt> is a shorthand for
--   <tt>[edBlockSensitive| ... /// ... |]</tt>
edBS :: QuasiQuoter

-- | <tt>[edBI| ... /// ... |]</tt> is a shorthand for
--   <tt>[edBlockInsensitive| ... /// ... |]</tt>
edBI :: QuasiQuoter

-- | <tt>[ed_| ... /// ... |]</tt> compiles a <a>SearchReplace</a> template
--   to produce a function that takes the RE options (e.g., a
--   <a>SimpleREOptions</a> value) and yields the <a>SearchReplace</a>
--   template compiled with those options. For example,
--   
--   <pre>
--   s *=~/ [ed_|${hex}([0-9a-f]+)///0x${hex}|] MultilineInsensitive
--   </pre>
--   
--   prefixes the hexadecimal digit strings in s with <tt>0x</tt>, allowing
--   for upper- or lower-case hex digits (which is entirely equivalent in
--   this example to just using
--   <tt>[edMultilineInsensitive|[0-9a-f]+|]</tt>).
ed_ :: QuasiQuoter

-- | quasi quoter for CaptureID: <tt>[cp|0|]</tt>, <tt>[cp|0|]</tt>, etc.,
--   indexing captures by classic positional numbers, and
--   <tt>[cp|foo|]</tt>, etc., referencing a named capture <tt>[re| ...
--   ${foo}( ... ) ... |]</tt>.
cp :: QuasiQuoter
instance Text.RE.ZeInternals.Types.IsRegex.IsRegex Text.RE.ZeInternals.TDFA.RE (Data.Sequence.Internal.Seq GHC.Types.Char)

module Text.RE.TDFA.ByteString.Lazy

-- | find all the matches in the argument text; e.g., to count the number
--   of naturals in s:
--   
--   <pre>
--   countMatches $ s *=~ [re|[0-9]+|]
--   </pre>
(*=~) :: ByteString -> RE -> Matches ByteString

-- | find the first match in the argument text; e.g., to test if there is a
--   natural number in the input text:
--   
--   <pre>
--   matched $ s ?=~ [re|[0-9]+|]
--   </pre>
(?=~) :: ByteString -> RE -> Match ByteString

-- | search and replace all matches in the argument text; e.g., this
--   section will convert every YYYY-MM-DD format date in its argument text
--   into a DD/MM/YYYY date:
--   
--   <pre>
--   (*=~/ [ed|${y}([0-9]{4})-0*${m}([0-9]{2})-0*${d}([0-9]{2})///${d}/${m}/${y}|])
--   </pre>
(*=~/) :: ByteString -> SearchReplace RE ByteString -> ByteString

-- | search and replace the first occurrence only (if any) in the input
--   text e.g., to prefix the first string of four hex digits in the input
--   text, if any, with <tt>0x</tt>:
--   
--   <pre>
--   (?=~/ [ed|[0-9A-Fa-f]{4}///0x$0|])
--   </pre>
(?=~/) :: ByteString -> SearchReplace RE ByteString -> ByteString

-- | the result of matching a RE against a text (with <tt>*=~</tt>),
--   retaining the text that was matched against
data Matches a

-- | the source text being matched
matchesSource :: Matches a -> a

-- | all <a>Match</a> instances found, left to right
allMatches :: Matches a -> [Match a]

-- | tests whether the RE matched the source text at all
anyMatches :: Matches a -> Bool

-- | count the matches
countMatches :: Matches a -> Int

-- | list the texts that Matched
matches :: Matches a -> [a]

-- | the result of matching a RE to a text once (with <tt>?=~</tt>),
--   retaining the text that was matched against
data Match a

-- | the whole source text
matchSource :: Match a -> a

-- | tests whether the RE matched the source text at all
matched :: Match a -> Bool

-- | yields the text matched by the RE, Nothing if no match
matchedText :: Match a -> Maybe a

-- | the RE type for this back end representing a well-formed, compiled RE
data RE

-- | extract the RE source string from the <tt>RE</tt>
reSource :: RE -> String

-- | the default API uses these simple, universal RE options, which get
--   auto-converted into the appropriate back-end <a>REOptions_</a>
data SimpleREOptions

-- | case-sensitive with ^ and $ matching the start and end of a line
MultilineSensitive :: SimpleREOptions

-- | case-insensitive with ^ and $ matsh the start and end of a line
MultilineInsensitive :: SimpleREOptions

-- | case-sensitive with ^ and $ matching the start and end of the input
--   text
BlockSensitive :: SimpleREOptions

-- | case-insensitive with ^ and $ matching the start and end of the input
--   text
BlockInsensitive :: SimpleREOptions

-- | contains a compiled RE and replacement template
data SearchReplace re s
SearchReplace :: !re -> !s -> SearchReplace re s

-- | the RE to match a string to replace
[getSearch] :: SearchReplace re s -> !re

-- | the replacement template with ${cap} used to identify a capture (by
--   number or name if one was given) and <tt>$$</tt> being used to escape
--   a single <a>$</a>
[getTemplate] :: SearchReplace re s -> !s

-- | compile a <a>String</a> into a <a>RE</a> with the default options,
--   generating an error if the RE is not well formed
compileRegex :: (Functor m, Monad m, MonadFail m) => String -> m RE

-- | compile a <a>String</a> into a <a>RE</a> using the given
--   <tt>SimpleREOptions</tt>, generating an error if the RE is not well
--   formed
compileRegexWith :: (Functor m, Monad m, MonadFail m) => SimpleREOptions -> String -> m RE

-- | compile a SearchReplace template generating errors if the RE or the
--   template are not well formed, all capture references being checked
compileSearchReplace :: (Monad m, MonadFail m, Functor m, IsRegex RE s) => String -> String -> m (SearchReplace RE s)

-- | compile a SearchReplace template, with simple options, generating
--   errors if the RE or the template are not well formed, all capture
--   references being checked
compileSearchReplaceWith :: (Monad m, MonadFail m, Functor m, IsRegex RE s) => SimpleREOptions -> String -> String -> m (SearchReplace RE s)

-- | convert a string into a RE that matches that string, and apply it to
--   an argument continuation function to make up the RE string to be
--   compiled; e.g., to compile a RE that will only match the string:
--   
--   <pre>
--   maybe undefined id . escape (("^"++) . (++"$"))
--   </pre>
escape :: (Functor m, Monad m, MonadFail m) => (String -> String) -> String -> m RE

-- | a variant of <a>escape</a> where the <a>SimpleREOptions</a> are
--   specified
escapeWith :: (Functor m, Monad m, MonadFail m) => SimpleREOptions -> (String -> String) -> String -> m RE

-- | Convert a string into a regular expression that will match that string
escapeREString :: String -> String

-- | the `regex-base` polymorphic match operator
(=~) :: (Typeable a, RegexContext Regex ByteString a) => ByteString -> RE -> a

-- | the `regex-base` monadic, polymorphic match operator
(=~~) :: (Monad m, MonadFail m, Functor m, Typeable a, RegexContext Regex ByteString a) => ByteString -> RE -> m a

-- | <tt>[re| ... |]</tt>, is equivalent to <tt>[reMultilineSensitive| ...
--   |]</tt>, compiling a case-sensitive, multi-line RE
re :: QuasiQuoter

-- | <tt>[reMultilineSensitive| ... |]</tt>, compiles a case-sensitive,
--   multi-line RE
reMultilineSensitive :: QuasiQuoter

-- | <tt>[reMultilineInsensitive| ... |]</tt>, compiles a case-insensitive,
--   multi-line RE
reMultilineInsensitive :: QuasiQuoter

-- | <tt>[reMultilineInsensitive| ... |]</tt>, compiles a case-sensitive,
--   non-multi-line RE
reBlockSensitive :: QuasiQuoter

-- | <tt>[reMultilineInsensitive| ... |]</tt>, compiles a case-insensitive,
--   non-multi-line RE
reBlockInsensitive :: QuasiQuoter

-- | <tt>[reMS| ... |]</tt> is a shorthand for <tt>[reMultilineSensitive|
--   ... |]</tt>
reMS :: QuasiQuoter

-- | <tt>[reMI| ... |]</tt> is a shorthand for <tt>[reMultilineInsensitive|
--   ... |]</tt>
reMI :: QuasiQuoter

-- | <tt>[reBS| ... |]</tt> is a shorthand for <tt>[reBlockSensitive| ...
--   |]</tt>
reBS :: QuasiQuoter

-- | <tt>[reBI| ... |]</tt> is a shorthand for <tt>[reBlockInsensitive| ...
--   |]</tt>
reBI :: QuasiQuoter

-- | <tt>[re_| ... |]</tt> compiles a RE to produce a function that takes
--   the RE options (e.g., a <a>SimpleREOptions</a> value) and yields the
--   RE compiled with those options. For example,
--   
--   <pre>
--   countMatches $ s *=~ [re_|[0-9a-f]+|] MultilineInsensitive
--   </pre>
--   
--   counts the number of hexadecimal digit strings in <tt>s</tt>, allowing
--   for upper- or lower-case hex digits (which is entirely equivalent in
--   this example to just using
--   <tt>[reMultilineInsensitive|[0-9a-f]+|]</tt>).
re_ :: QuasiQuoter

-- | <tt>[edMultilineSensitive| ... /// ... |]</tt> compiles a
--   case-sensitive, multi-line <a>SearchReplace</a> template
edMultilineSensitive :: QuasiQuoter

-- | <tt>[edMultilineInsensitive| ... /// ... |]</tt> compiles a
--   case-insensitive, multi-line <a>SearchReplace</a> template
edMultilineInsensitive :: QuasiQuoter

-- | <tt>[edBlockSensitive| ... /// ... |]</tt> compiles a case-sensitive,
--   non-multi-line <a>SearchReplace</a> template
edBlockSensitive :: QuasiQuoter

-- | <tt>[edBlockInsensitive| ... /// ... |]</tt> compiles a
--   case-insensitive, non-multi-line <a>SearchReplace</a> template
edBlockInsensitive :: QuasiQuoter

-- | <tt>[ed| ... /// ... |]</tt>, is equivalent to
--   <tt>[edMultilineSensitive| ... /// ... |]</tt>, compiling a
--   case-sensitive, multi-line <a>SearchReplace</a>
ed :: QuasiQuoter

-- | <tt>[edMS| ... /// ... |]</tt> is a shorthand for
--   <tt>[edMultilineSensitive| ... /// ... |]</tt>
edMS :: QuasiQuoter

-- | <tt>[edMI| ... /// ... |]</tt> is a shorthand for
--   <tt>[edMultilineInsensitive| ... /// ... |]</tt>
edMI :: QuasiQuoter

-- | <tt>[edBS| ... /// ... |]</tt> is a shorthand for
--   <tt>[edBlockSensitive| ... /// ... |]</tt>
edBS :: QuasiQuoter

-- | <tt>[edBI| ... /// ... |]</tt> is a shorthand for
--   <tt>[edBlockInsensitive| ... /// ... |]</tt>
edBI :: QuasiQuoter

-- | <tt>[ed_| ... /// ... |]</tt> compiles a <a>SearchReplace</a> template
--   to produce a function that takes the RE options (e.g., a
--   <a>SimpleREOptions</a> value) and yields the <a>SearchReplace</a>
--   template compiled with those options. For example,
--   
--   <pre>
--   s *=~/ [ed_|${hex}([0-9a-f]+)///0x${hex}|] MultilineInsensitive
--   </pre>
--   
--   prefixes the hexadecimal digit strings in s with <tt>0x</tt>, allowing
--   for upper- or lower-case hex digits (which is entirely equivalent in
--   this example to just using
--   <tt>[edMultilineInsensitive|[0-9a-f]+|]</tt>).
ed_ :: QuasiQuoter

-- | quasi quoter for CaptureID: <tt>[cp|0|]</tt>, <tt>[cp|0|]</tt>, etc.,
--   indexing captures by classic positional numbers, and
--   <tt>[cp|foo|]</tt>, etc., referencing a named capture <tt>[re| ...
--   ${foo}( ... ) ... |]</tt>.
cp :: QuasiQuoter
instance Text.RE.ZeInternals.Types.IsRegex.IsRegex Text.RE.ZeInternals.TDFA.RE Data.ByteString.Lazy.Internal.ByteString

module Text.RE.TDFA.ByteString

-- | find all the matches in the argument text; e.g., to count the number
--   of naturals in s:
--   
--   <pre>
--   countMatches $ s *=~ [re|[0-9]+|]
--   </pre>
(*=~) :: ByteString -> RE -> Matches ByteString

-- | find the first match in the argument text; e.g., to test if there is a
--   natural number in the input text:
--   
--   <pre>
--   matched $ s ?=~ [re|[0-9]+|]
--   </pre>
(?=~) :: ByteString -> RE -> Match ByteString

-- | search and replace all matches in the argument text; e.g., this
--   section will convert every YYYY-MM-DD format date in its argument text
--   into a DD/MM/YYYY date:
--   
--   <pre>
--   (*=~/ [ed|${y}([0-9]{4})-0*${m}([0-9]{2})-0*${d}([0-9]{2})///${d}/${m}/${y}|])
--   </pre>
(*=~/) :: ByteString -> SearchReplace RE ByteString -> ByteString

-- | search and replace the first occurrence only (if any) in the input
--   text e.g., to prefix the first string of four hex digits in the input
--   text, if any, with <tt>0x</tt>:
--   
--   <pre>
--   (?=~/ [ed|[0-9A-Fa-f]{4}///0x$0|])
--   </pre>
(?=~/) :: ByteString -> SearchReplace RE ByteString -> ByteString

-- | the result of matching a RE against a text (with <tt>*=~</tt>),
--   retaining the text that was matched against
data Matches a

-- | the source text being matched
matchesSource :: Matches a -> a

-- | all <a>Match</a> instances found, left to right
allMatches :: Matches a -> [Match a]

-- | tests whether the RE matched the source text at all
anyMatches :: Matches a -> Bool

-- | count the matches
countMatches :: Matches a -> Int

-- | list the texts that Matched
matches :: Matches a -> [a]

-- | the result of matching a RE to a text once (with <tt>?=~</tt>),
--   retaining the text that was matched against
data Match a

-- | the whole source text
matchSource :: Match a -> a

-- | tests whether the RE matched the source text at all
matched :: Match a -> Bool

-- | yields the text matched by the RE, Nothing if no match
matchedText :: Match a -> Maybe a

-- | the RE type for this back end representing a well-formed, compiled RE
data RE

-- | extract the RE source string from the <tt>RE</tt>
reSource :: RE -> String

-- | the default API uses these simple, universal RE options, which get
--   auto-converted into the appropriate back-end <a>REOptions_</a>
data SimpleREOptions

-- | case-sensitive with ^ and $ matching the start and end of a line
MultilineSensitive :: SimpleREOptions

-- | case-insensitive with ^ and $ matsh the start and end of a line
MultilineInsensitive :: SimpleREOptions

-- | case-sensitive with ^ and $ matching the start and end of the input
--   text
BlockSensitive :: SimpleREOptions

-- | case-insensitive with ^ and $ matching the start and end of the input
--   text
BlockInsensitive :: SimpleREOptions

-- | contains a compiled RE and replacement template
data SearchReplace re s
SearchReplace :: !re -> !s -> SearchReplace re s

-- | the RE to match a string to replace
[getSearch] :: SearchReplace re s -> !re

-- | the replacement template with ${cap} used to identify a capture (by
--   number or name if one was given) and <tt>$$</tt> being used to escape
--   a single <a>$</a>
[getTemplate] :: SearchReplace re s -> !s

-- | compile a <a>String</a> into a <a>RE</a> with the default options,
--   generating an error if the RE is not well formed
compileRegex :: (Functor m, Monad m, MonadFail m) => String -> m RE

-- | compile a <a>String</a> into a <a>RE</a> using the given
--   <tt>SimpleREOptions</tt>, generating an error if the RE is not well
--   formed
compileRegexWith :: (Functor m, Monad m, MonadFail m) => SimpleREOptions -> String -> m RE

-- | compile a SearchReplace template generating errors if the RE or the
--   template are not well formed, all capture references being checked
compileSearchReplace :: (Monad m, MonadFail m, Functor m, IsRegex RE s) => String -> String -> m (SearchReplace RE s)

-- | compile a SearchReplace template, with simple options, generating
--   errors if the RE or the template are not well formed, all capture
--   references being checked
compileSearchReplaceWith :: (Monad m, MonadFail m, Functor m, IsRegex RE s) => SimpleREOptions -> String -> String -> m (SearchReplace RE s)

-- | convert a string into a RE that matches that string, and apply it to
--   an argument continuation function to make up the RE string to be
--   compiled; e.g., to compile a RE that will only match the string:
--   
--   <pre>
--   maybe undefined id . escape (("^"++) . (++"$"))
--   </pre>
escape :: (Functor m, Monad m, MonadFail m) => (String -> String) -> String -> m RE

-- | a variant of <a>escape</a> where the <a>SimpleREOptions</a> are
--   specified
escapeWith :: (Functor m, Monad m, MonadFail m) => SimpleREOptions -> (String -> String) -> String -> m RE

-- | Convert a string into a regular expression that will match that string
escapeREString :: String -> String

-- | the `regex-base` polymorphic match operator
(=~) :: (Typeable a, RegexContext Regex ByteString a) => ByteString -> RE -> a

-- | the `regex-base` monadic, polymorphic match operator
(=~~) :: (Monad m, MonadFail m, Functor m, Typeable a, RegexContext Regex ByteString a) => ByteString -> RE -> m a

-- | <tt>[re| ... |]</tt>, is equivalent to <tt>[reMultilineSensitive| ...
--   |]</tt>, compiling a case-sensitive, multi-line RE
re :: QuasiQuoter

-- | <tt>[reMultilineSensitive| ... |]</tt>, compiles a case-sensitive,
--   multi-line RE
reMultilineSensitive :: QuasiQuoter

-- | <tt>[reMultilineInsensitive| ... |]</tt>, compiles a case-insensitive,
--   multi-line RE
reMultilineInsensitive :: QuasiQuoter

-- | <tt>[reMultilineInsensitive| ... |]</tt>, compiles a case-sensitive,
--   non-multi-line RE
reBlockSensitive :: QuasiQuoter

-- | <tt>[reMultilineInsensitive| ... |]</tt>, compiles a case-insensitive,
--   non-multi-line RE
reBlockInsensitive :: QuasiQuoter

-- | <tt>[reMS| ... |]</tt> is a shorthand for <tt>[reMultilineSensitive|
--   ... |]</tt>
reMS :: QuasiQuoter

-- | <tt>[reMI| ... |]</tt> is a shorthand for <tt>[reMultilineInsensitive|
--   ... |]</tt>
reMI :: QuasiQuoter

-- | <tt>[reBS| ... |]</tt> is a shorthand for <tt>[reBlockSensitive| ...
--   |]</tt>
reBS :: QuasiQuoter

-- | <tt>[reBI| ... |]</tt> is a shorthand for <tt>[reBlockInsensitive| ...
--   |]</tt>
reBI :: QuasiQuoter

-- | <tt>[re_| ... |]</tt> compiles a RE to produce a function that takes
--   the RE options (e.g., a <a>SimpleREOptions</a> value) and yields the
--   RE compiled with those options. For example,
--   
--   <pre>
--   countMatches $ s *=~ [re_|[0-9a-f]+|] MultilineInsensitive
--   </pre>
--   
--   counts the number of hexadecimal digit strings in <tt>s</tt>, allowing
--   for upper- or lower-case hex digits (which is entirely equivalent in
--   this example to just using
--   <tt>[reMultilineInsensitive|[0-9a-f]+|]</tt>).
re_ :: QuasiQuoter

-- | <tt>[edMultilineSensitive| ... /// ... |]</tt> compiles a
--   case-sensitive, multi-line <a>SearchReplace</a> template
edMultilineSensitive :: QuasiQuoter

-- | <tt>[edMultilineInsensitive| ... /// ... |]</tt> compiles a
--   case-insensitive, multi-line <a>SearchReplace</a> template
edMultilineInsensitive :: QuasiQuoter

-- | <tt>[edBlockSensitive| ... /// ... |]</tt> compiles a case-sensitive,
--   non-multi-line <a>SearchReplace</a> template
edBlockSensitive :: QuasiQuoter

-- | <tt>[edBlockInsensitive| ... /// ... |]</tt> compiles a
--   case-insensitive, non-multi-line <a>SearchReplace</a> template
edBlockInsensitive :: QuasiQuoter

-- | <tt>[ed| ... /// ... |]</tt>, is equivalent to
--   <tt>[edMultilineSensitive| ... /// ... |]</tt>, compiling a
--   case-sensitive, multi-line <a>SearchReplace</a>
ed :: QuasiQuoter

-- | <tt>[edMS| ... /// ... |]</tt> is a shorthand for
--   <tt>[edMultilineSensitive| ... /// ... |]</tt>
edMS :: QuasiQuoter

-- | <tt>[edMI| ... /// ... |]</tt> is a shorthand for
--   <tt>[edMultilineInsensitive| ... /// ... |]</tt>
edMI :: QuasiQuoter

-- | <tt>[edBS| ... /// ... |]</tt> is a shorthand for
--   <tt>[edBlockSensitive| ... /// ... |]</tt>
edBS :: QuasiQuoter

-- | <tt>[edBI| ... /// ... |]</tt> is a shorthand for
--   <tt>[edBlockInsensitive| ... /// ... |]</tt>
edBI :: QuasiQuoter

-- | <tt>[ed_| ... /// ... |]</tt> compiles a <a>SearchReplace</a> template
--   to produce a function that takes the RE options (e.g., a
--   <a>SimpleREOptions</a> value) and yields the <a>SearchReplace</a>
--   template compiled with those options. For example,
--   
--   <pre>
--   s *=~/ [ed_|${hex}([0-9a-f]+)///0x${hex}|] MultilineInsensitive
--   </pre>
--   
--   prefixes the hexadecimal digit strings in s with <tt>0x</tt>, allowing
--   for upper- or lower-case hex digits (which is entirely equivalent in
--   this example to just using
--   <tt>[edMultilineInsensitive|[0-9a-f]+|]</tt>).
ed_ :: QuasiQuoter

-- | quasi quoter for CaptureID: <tt>[cp|0|]</tt>, <tt>[cp|0|]</tt>, etc.,
--   indexing captures by classic positional numbers, and
--   <tt>[cp|foo|]</tt>, etc., referencing a named capture <tt>[re| ...
--   ${foo}( ... ) ... |]</tt>.
cp :: QuasiQuoter
instance Text.RE.ZeInternals.Types.IsRegex.IsRegex Text.RE.ZeInternals.TDFA.RE Data.ByteString.Internal.Type.ByteString

module Text.RE.TDFA

-- | find all the matches in the argument text; e.g., to count the number
--   of naturals in s:
--   
--   <pre>
--   countMatches $ s *=~ [re|[0-9]+|]
--   </pre>
(*=~) :: IsRegex RE s => s -> RE -> Matches s

-- | find the first match in the argument text; e.g., to test if there is a
--   natural number in the input text:
--   
--   <pre>
--   matched $ s ?=~ [re|[0-9]+|]
--   </pre>
(?=~) :: IsRegex RE s => s -> RE -> Match s

-- | search and replace all matches in the argument text; e.g., this
--   section will convert every YYYY-MM-DD format date in its argument text
--   into a DD/MM/YYYY date:
--   
--   <pre>
--   (*=~/ [ed|${y}([0-9]{4})-0*${m}([0-9]{2})-0*${d}([0-9]{2})///${d}/${m}/${y}|])
--   </pre>
(*=~/) :: IsRegex RE s => s -> SearchReplace RE s -> s

-- | search and replace the first occurrence only
(?=~/) :: IsRegex RE s => s -> SearchReplace RE s -> s

-- | the result of matching a RE against a text (with <tt>*=~</tt>),
--   retaining the text that was matched against
data Matches a

-- | the source text being matched
matchesSource :: Matches a -> a

-- | all <a>Match</a> instances found, left to right
allMatches :: Matches a -> [Match a]

-- | tests whether the RE matched the source text at all
anyMatches :: Matches a -> Bool

-- | count the matches
countMatches :: Matches a -> Int

-- | list the texts that Matched
matches :: Matches a -> [a]

-- | the result of matching a RE to a text once (with <tt>?=~</tt>),
--   retaining the text that was matched against
data Match a

-- | the whole source text
matchSource :: Match a -> a

-- | tests whether the RE matched the source text at all
matched :: Match a -> Bool

-- | yields the text matched by the RE, Nothing if no match
matchedText :: Match a -> Maybe a

-- | the RE type for this back end representing a well-formed, compiled RE
data RE

-- | some functions in the <a>Text.RE.TestBench</a> need the back end to be
--   passed dynamically as a <a>RegexType</a> parameters: use
--   <a>regexType</a> for this
regexType :: RegexType

-- | extract the <a>REOptions</a> from the <tt>RE</tt>
reOptions :: RE -> REOptions

-- | extract the RE source string from the <tt>RE</tt>
reSource :: RE -> String

-- | extract the <a>CaptureNames</a> from the <tt>RE</tt>
reCaptureNames :: RE -> CaptureNames

-- | extract the back end compiled <a>Regex</a> type from the <tt>RE</tt>
reRegex :: RE -> Regex

-- | the default API uses these simple, universal RE options, which get
--   auto-converted into the appropriate back-end <a>REOptions_</a>
data SimpleREOptions

-- | case-sensitive with ^ and $ matching the start and end of a line
MultilineSensitive :: SimpleREOptions

-- | case-insensitive with ^ and $ matsh the start and end of a line
MultilineInsensitive :: SimpleREOptions

-- | case-sensitive with ^ and $ matching the start and end of the input
--   text
BlockSensitive :: SimpleREOptions

-- | case-insensitive with ^ and $ matching the start and end of the input
--   text
BlockInsensitive :: SimpleREOptions

-- | a number of types can be used to encode <a>REOptions_</a>, each of
--   which is made a member of this class
class IsOption o

-- | convert the <tt>o</tt> type into an <tt>REOptions</tt>
makeREOptions :: IsOption o => o -> REOptions

-- | and the REOptions for this back end (see <a>Text.RE.REOptions</a> for
--   details)
type REOptions = REOptions_ RE CompOption ExecOption

-- | the default <a>REOptions</a>
defaultREOptions :: REOptions

-- | the default <a>REOptions</a> but with no RE macros defined
noPreludeREOptions :: REOptions

-- | convert a universal <tt>SimpleReOptions</tt> into the <a>REOptions</a>
--   used by this back end
unpackSimpleREOptions :: SimpleREOptions -> REOptions

-- | contains a compiled RE and replacement template
data SearchReplace re s
SearchReplace :: !re -> !s -> SearchReplace re s

-- | the RE to match a string to replace
[getSearch] :: SearchReplace re s -> !re

-- | the replacement template with ${cap} used to identify a capture (by
--   number or name if one was given) and <tt>$$</tt> being used to escape
--   a single <a>$</a>
[getTemplate] :: SearchReplace re s -> !s

-- | compile a <a>String</a> into a <a>RE</a> with the default options,
--   generating an error if the RE is not well formed
compileRegex :: (Functor m, Monad m, MonadFail m) => String -> m RE

-- | compile a <a>String</a> into a <a>RE</a> using the given
--   <tt>SimpleREOptions</tt>, generating an error if the RE is not well
--   formed
compileRegexWith :: (Functor m, Monad m, MonadFail m) => SimpleREOptions -> String -> m RE

-- | compile a <a>String</a> into a <a>RE</a> using the given
--   <tt>SimpleREOptions</tt>, generating an error if the RE is not well
--   formed
compileRegexWithOptions :: (IsOption o, Functor m, Monad m, MonadFail m) => o -> String -> m RE

-- | compile a SearchReplace template generating errors if the RE or the
--   template are not well formed, all capture references being checked
compileSearchReplace :: (Monad m, MonadFail m, Functor m, IsRegex RE s) => String -> String -> m (SearchReplace RE s)

-- | compile a SearchReplace template, with simple options, generating
--   errors if the RE or the template are not well formed, all capture
--   references being checked
compileSearchReplaceWith :: (Monad m, MonadFail m, Functor m, IsRegex RE s) => SimpleREOptions -> String -> String -> m (SearchReplace RE s)

-- | compile a SearchReplace template, with general options, generating
--   errors if the RE or the template are not well formed, all capture
--   references being checked
compileSearchReplaceWithOptions :: (Monad m, MonadFail m, Functor m, IsRegex RE s) => REOptions -> String -> String -> m (SearchReplace RE s)

-- | convert a string into a RE that matches that string, and apply it to
--   an argument continuation function to make up the RE string to be
--   compiled; e.g., to compile a RE that will only match the string:
--   
--   <pre>
--   maybe undefined id . escape (("^"++) . (++"$"))
--   </pre>
escape :: (Functor m, Monad m, MonadFail m) => (String -> String) -> String -> m RE

-- | a variant of <a>escape</a> where the <a>SimpleREOptions</a> are
--   specified
escapeWith :: (Functor m, Monad m, MonadFail m) => SimpleREOptions -> (String -> String) -> String -> m RE

-- | a variant of <a>escapeWith</a> that allows an <a>IsOption</a> RE
--   option to be specified
escapeWithOptions :: (IsOption o, Functor m, Monad m, MonadFail m) => o -> (String -> String) -> String -> m RE

-- | Convert a string into a regular expression that will match that string
escapeREString :: String -> String

-- | the regex-base polymorphic match operator
(=~) :: (RegexContext Regex s a, RegexMaker Regex CompOption ExecOption s) => s -> RE -> a

-- | the regex-base monadic, polymorphic match operator
(=~~) :: (Monad m, MonadFail m, RegexContext Regex s a, RegexMaker Regex CompOption ExecOption s) => s -> RE -> m a

-- | <tt>[re| ... |]</tt>, is equivalent to <tt>[reMultilineSensitive| ...
--   |]</tt>, compiling a case-sensitive, multi-line RE
re :: QuasiQuoter

-- | <tt>[reMultilineSensitive| ... |]</tt>, compiles a case-sensitive,
--   multi-line RE
reMultilineSensitive :: QuasiQuoter

-- | <tt>[reMultilineInsensitive| ... |]</tt>, compiles a case-insensitive,
--   multi-line RE
reMultilineInsensitive :: QuasiQuoter

-- | <tt>[reMultilineInsensitive| ... |]</tt>, compiles a case-sensitive,
--   non-multi-line RE
reBlockSensitive :: QuasiQuoter

-- | <tt>[reMultilineInsensitive| ... |]</tt>, compiles a case-insensitive,
--   non-multi-line RE
reBlockInsensitive :: QuasiQuoter

-- | <tt>[reMS| ... |]</tt> is a shorthand for <tt>[reMultilineSensitive|
--   ... |]</tt>
reMS :: QuasiQuoter

-- | <tt>[reMI| ... |]</tt> is a shorthand for <tt>[reMultilineInsensitive|
--   ... |]</tt>
reMI :: QuasiQuoter

-- | <tt>[reBS| ... |]</tt> is a shorthand for <tt>[reBlockSensitive| ...
--   |]</tt>
reBS :: QuasiQuoter

-- | <tt>[reBI| ... |]</tt> is a shorthand for <tt>[reBlockInsensitive| ...
--   |]</tt>
reBI :: QuasiQuoter

-- | <tt>[re_| ... |]</tt> compiles a RE to produce a function that takes
--   the RE options (e.g., a <a>SimpleREOptions</a> value) and yields the
--   RE compiled with those options. For example,
--   
--   <pre>
--   countMatches $ s *=~ [re_|[0-9a-f]+|] MultilineInsensitive
--   </pre>
--   
--   counts the number of hexadecimal digit strings in <tt>s</tt>, allowing
--   for upper- or lower-case hex digits (which is entirely equivalent in
--   this example to just using
--   <tt>[reMultilineInsensitive|[0-9a-f]+|]</tt>).
re_ :: QuasiQuoter

-- | the <tt>[ed| ... /// ... |]</tt> quasi quoters
ed :: QuasiQuoter

-- | the <tt>[ed| ... /// ... |]</tt> quasi quoters
edMultilineSensitive :: QuasiQuoter

-- | the <tt>[ed| ... /// ... |]</tt> quasi quoters
edMultilineInsensitive :: QuasiQuoter

-- | the <tt>[ed| ... /// ... |]</tt> quasi quoters
edBlockSensitive :: QuasiQuoter

-- | the <tt>[ed| ... /// ... |]</tt> quasi quoters
edBlockInsensitive :: QuasiQuoter

-- | the <tt>[ed| ... /// ... |]</tt> quasi quoters
edMS :: QuasiQuoter

-- | the <tt>[ed| ... /// ... |]</tt> quasi quoters
edMI :: QuasiQuoter

-- | the <tt>[ed| ... /// ... |]</tt> quasi quoters
edBS :: QuasiQuoter

-- | the <tt>[ed| ... /// ... |]</tt> quasi quoters
edBI :: QuasiQuoter

-- | the <tt>[ed| ... /// ... |]</tt> quasi quoters
ed_ :: QuasiQuoter

-- | quasi quoter for CaptureID: <tt>[cp|0|]</tt>, <tt>[cp|0|]</tt>, etc.,
--   indexing captures by classic positional numbers, and
--   <tt>[cp|foo|]</tt>, etc., referencing a named capture <tt>[re| ...
--   ${foo}( ... ) ... |]</tt>.
cp :: QuasiQuoter

-- | the standard table of <a>Macros</a> used to compile REs (which can be
--   extended or replace: see <a>Text.RE.TestBench</a>)
prelude :: Macros RE

-- | the standard <a>MacroEnv</a> for this back end (see
--   <a>Text.RE.TestBench</a>)
preludeEnv :: MacroEnv

-- | the macros in the standard environment that are failing their tests
--   (checked by the test suite to be empty)
preludeTestsFailing :: [MacroID]

-- | a table the standard macros in markdown format
preludeTable :: String

-- | a summary of the macros in the standard environment for this back end
--   in plain text
preludeSummary :: PreludeMacro -> String

-- | a listing of the RE text for each macro in the standard environment
--   with all macros expanded to normal form
preludeSources :: String

-- | the prelude source of a given macro in the standard environment
preludeSource :: PreludeMacro -> String
